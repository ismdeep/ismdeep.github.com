<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ismdeep</title>
  
  <subtitle>Doubt is the greatest enemy.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ismdeep.com/"/>
  <updated>2021-06-25T02:16:29.922Z</updated>
  <id>https://ismdeep.com/</id>
  
  <author>
    <name>ismdeep</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows的现状：Windows 10用了多少个不一致的UI层？</title>
    <link href="https://ismdeep.com/posts/2021-06-22-state-of-the-windows-how-many-layers-of-ui-inconsistencies-are-in-windows-10.html"/>
    <id>https://ismdeep.com/posts/2021-06-22-state-of-the-windows-how-many-layers-of-ui-inconsistencies-are-in-windows-10.html</id>
    <published>2021-06-22T07:13:11.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>我们可能都听说过这个梗：如果你在Windows 10中挖掘得足够深，你会发现可以追溯到Windows 3.x时代的元素。但这实际上是真的吗？在这篇文章中，我们将来探寻Windows中到底有多少个UI层，以及它们是何时被首次引入的。</p><p>为了这个实验的目的，我选择了最新的Windows 10 Insider Build（截至2021年2月6日），即Windows 10 build 21301。</p><p>所以，来不及解释了，赶紧上车。</p><h1 id="第一层：Fluent-Design"><a href="#第一层：Fluent-Design" class="headerlink" title="第一层：Fluent Design"></a>第一层：Fluent Design</h1><p>首先，我们从最新和最伟大的，流畅设计开始。流利设计于2017年宣布，并与Windows 10 1803更新一起推出，是现代设计语言2（MDL2）的重大重新设计，旨在带来光、深度、运动、材料和规模等元素。它还引入了揭幕效果和亚克力半透明背景。</p><p>截至目前，大多数收件箱（UWP）应用程序已经升级，以利用Fluent元素，以及一些更面向前台的元素，如开始菜单、活动中心和登录屏幕。</p><p>尽管”Fluent Design”得到了好评，但大多数爱好者认为此举太少、太晚了，因为只有一小部分功能通过这种新的设计风格得到了加强。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/18b4f09d05fdbcb468dc3d4e1550bc2e-8595be.png" alt="windows-10-x64-2021-02-06-19-26-06"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/c349f7de56319c657b1c9a06cbfe37a8-973814.png" alt="windows-10-x64-2021-02-06-18-37-21-2"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/9f1dabf457c499c1c52563ff59d97c90-454575.png" alt="windows-10-x64-2021-02-06-18-37-43-2"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/3b0778764921af25ab0fd70f88e1a2e4-ec9cc9.png" alt="windows-10-x64-2021-02-06-18-38-23"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/a00bfeacf059ab33b3b0f9979e2280b9-382164.png" alt="windows-10-x64-2021-02-06-18-38-28"></p><h1 id="第二层：Metro"><a href="#第二层：Metro" class="headerlink" title="第二层：Metro"></a>第二层：Metro</h1><p>就在我们深入挖掘操作系统的时候，我们可以看到自Windows 8/8.1以来没有升级过的元素。</p><p>其中一些是明显的遗漏，如音量、USB弹出以及登录屏幕的一些元素。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/6c5721f7e75103296c415c288e03f78e-969e36.png" alt="vlcsnap-2021-02-06-19h42m58s859"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/57e6ab78f4b1227890627ce513bd2b9d-6fb9d8.png" alt="windows-10-x64-2021-02-06-18-39-08-2"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/2556f2411ce57a4750478da863f4b2d9-728320.png" alt="windows-10-x64-2021-02-06-18-39-24"></p><p>其他Metro元素，虽然没有那么突出，但有开机画面（很快将被更新的画面取代）和WinRE。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/5795778a09466b14ae57c462b19e0a74-6c1a3e.png" alt="windows-10-x64-2021-02-06-18-42-32"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/63c97e33b250639787b84a5775f94c6d-507335.png" alt="windows-10-x64-2021-02-06-18-42-47"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/befbad0586effc5e035fbd95540111a8-63a980.png" alt="7989boot"></p><p>你知道吗：第一次引入旋转圆点是在Windows 8 build 7989。</p><h1 id="第三层：Windows-8-Win32-elements"><a href="#第三层：Windows-8-Win32-elements" class="headerlink" title="第三层：Windows 8 Win32 elements."></a>第三层：Windows 8 Win32 elements.</h1><p>就像Windows 10一样，Windows 8也被不一致的问题所困扰（无论好坏）。然而，Windows 8为主要的用户元素增加了有意义的改进，如Windows Explorer或任务管理器。虽然它们在随后的Windows 10更新中会得到一些生活质量的改善，但变化是最小的。</p><p>此外，Windows 8带来的一个重要变化是重新设计了文件传输对话框。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/2d0fe5991b9564bf78b1191a87d27298-cf2302.png" alt="q"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/b1a9c7702aeeda83f8d98780e0b5cf3b-bd4474.png" alt="windows-10-x64-2021-02-06-18-41-42"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/758ae4acba59731d07a408a283e70bf4-deee77.png" alt="windows-10-x64-2021-02-06-18-44-45"></p><p>其中一些变化从Windows 7开始，这使我们来到了第四层。</p><h1 id="第四层：Windows-7-UI-elements"><a href="#第四层：Windows-7-UI-elements" class="headerlink" title="第四层：Windows 7 UI elements"></a>第四层：Windows 7 UI elements</h1><p>毫无疑问，Windows 7是有史以来最受喜爱的Windows版本之一，因其在Windows Vista基础上的巨大提升而受到称赞。它带来了许多新功能，虽然没有Vista引入的那些功能那么重要，但使Windows 7成为一个非常坚实的操作系统，是Windows XP的真正继承者。然而，Windows 7带来的最臭名昭著的变化之一是Ribbon UI，这是一个从Office 2007移植的功能。用新的Ribbon UI更新的一些应用程序是Paint和Wordpad。</p><p>虽然在某些时候，微软决定废弃经典的画图，而采用新的画图3D（与Windows 10创意者更新一起推出），但在重大的反响之后，他们推翻了自己的决定。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/299ab0007aad2b98141e5dbb1408097a-88b238.png" alt="windows-10-x64-2021-02-06-18-45-38"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/1a6da87b67f96b57b7e42550aa7eda40-73063f.png" alt="windows-10-x64-2021-02-06-18-45-17"></p><p>其他在Windows 7中更新并一直保持不变的功能有：Windows Media Player 12、远程桌面连接和一些文件对话框。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/f3eb6efc2c8b7f3776950d213651939d-5daf11.png" alt="windows-10-x64-2021-02-06-18-46-33"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/98dd430364d5842b6f5dae098c081624-fc9cbd.png" alt="windows-10-x64-2021-02-06-18-47-00"></p><h1 id="第五层：Windows-Vista"><a href="#第五层：Windows-Vista" class="headerlink" title="第五层：Windows Vista."></a>第五层：Windows Vista.</h1><p>Windows Vista是一个具有纪念意义的Windows版本，它给平台带来了急需的现代化。几乎所有操作系统的基本要素都以某种方式得到了改进，从启动器到驱动模型。然而，正如我们现在都知道的，Windows Vista将成为有史以来最糟糕的Windows版本之一，从一开始就被各种问题所困扰。不过，为数不多的被称赞的功能之一是用户界面。它重新设计了一些自Windows 95以来没有更新过的基本要素。这一变化的主要推动者之一是引入了所谓的Aero Wizards，取代了以前的Wizard标准，即Wizard97。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/9cf476c00df551b984a143ed89868c00-3ff4fe.png" alt="windows-10-x64-2021-02-06-18-56-42"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/deda1aacc564130b5c1e09376b1a14db-6cf242.png" alt="windows-10-x64-2021-02-06-18-54-58"></p><p>在Windows Vista中重新设计的其他功能，在Windows 10中基本相同：控制面板、搜索程序、Windows传真和扫描。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/10230818e81267a0ff424976aaa48b32-139912.png" alt="windows-10-x64-2021-02-06-20-38-06"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/78c980312e88bb5de70c876486642cd2-8df5d8.png" alt="windows-10-x64-2021-02-06-18-51-54"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/29f220b3c58e6c6086a47a71b2649822-107af5.png" alt="windows-10-x64-2021-02-06-18-54-37"></p><p>说到 Windows Vista：你知道在某些特殊情况下，Windows 10会退回到Vista的启动画面吗？比如当你的显卡不支持标准启动屏幕使用的视频模式时，就会发生这种情况。</p><h1 id="第六层：Windows-XP"><a href="#第六层：Windows-XP" class="headerlink" title="第六层：Windows XP"></a>第六层：Windows XP</h1><p>信不信由你，没有那么多XP元素嵌入到Windows 10中。这可能是因为大多数基本要素已经被更新到Windows 2000中。然而，Windows 10包含一些来自XP的文件对话框，在安装驱动程序时可以看到这些对话框。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/ceaa88a2d38271b753af4166aed27fd5-e63af8.png" alt="dri"></p><h1 id="第七层：Windows-2000"><a href="#第七层：Windows-2000" class="headerlink" title="第七层：Windows 2000"></a>第七层：Windows 2000</h1><p>Windows 2000是微软NT系列操作系统的一个重要里程碑。它也是一块垫脚石，标志着开始向新的、统一的Windows愿景过渡。然而，Windows 2000仍然是一个面向商业的操作系统，这意味着它带来了许多为专家设计的新功能。</p><p>最重要的一个新增功能就是管理控制台（MMC），其UI元素自那时起，至今几乎没变。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/2af794583f3c4e3dc0e91272cd0f8e26-774ab5.png" alt="windows-10-x64-2021-02-06-19-05-34"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/50896409dfbcb900718ea78f8f66471e-86c085.png" alt="windows-10-x64-2021-02-06-19-04-39"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/82387a21f10004d96f0d211858733b85-8150a2.png" alt="windows-10-x64-2021-02-06-19-04-54"></p><p>在Windows 2000中引入的另一个功能是Windows安装程序，它的图标仍然与最初时一样。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/97155d138f355227e238fa8a7f279dd6-4dd4d4.png" alt="wi"></p><p>还有另一个没有变化过的UI元素（当然除了品牌效应）是winver，它的设计是在Windows 2000 build 1946中被引入的。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/f36f0655b6790b625e29ab80cc43d9eb-32f6e9.png" alt="windows2000-5.0.1946-about"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/9a11782dd1ca5d6fb0087baa3bb59f15-bba104.png" alt="windows-10-x64-2021-02-06-19-04-04"></p><p>虽然Windows 2000引入了许多针对高级用户的功能，但Windows 95可能是迄今为止最重要的Windows版本。它所引入的基本范式至今仍然有效。它引入了诸如开始菜单、上下文菜单、任务栏和回收站等功能。虽然这些功能经过多年的更新，但有些功能几乎完全保持不变。</p><h1 id="第八层：Windows-95-NT-4-0-中的元素"><a href="#第八层：Windows-95-NT-4-0-中的元素" class="headerlink" title="第八层：Windows 95/NT 4.0 中的元素"></a>第八层：Windows 95/NT 4.0 中的元素</h1><p>一个基本上是老式计算习惯的遗留物的元素，即人们必须保护他们宝贵的CRT屏幕，这就是屏保设置。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/cae1e6e40863f7c5c27c9d8429bd0b2f-d10bf0.png" alt="windows-95-2021-02-06-21-34-46-2"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/953573c4521a3423a32201cdaf786657-3919f0.png" alt="windows-10-x64-2021-02-06-19-10-29-1"></p><p>另一个惊人相似的元素是“运行”对话框。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/efc0d1fc4749f03a1e14d826fd8033bd-c52a6a.png" alt="windows-95-2021-02-06-21-34-55-3"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/d0b92b3c032f15fb9eb60410e9799063-76f214.png" alt="windows-10-x64-2021-02-06-19-10-53-1"></p><p>还有一个通过时间考验的常见UI元素是文件夹属性窗口。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/1986fa9346bdb225187a05d38b2ad05e-1fbd5d.png" alt="wi2-1"></p><p><img src="https://upload.ismdeep.com/images/2021/06/22/189f12d27b85176bb324d65628648f39-74f606.png" alt="nf"></p><p>还有很多UI元素自Windows 95以来就没有被碰过。这是一个永恒的设计的案例吗？</p><h1 id="第九层：像-Windows-3-1-和-DOS"><a href="#第九层：像-Windows-3-1-和-DOS" class="headerlink" title="第九层：像 Windows 3.1 和 DOS"></a>第九层：像 Windows 3.1 和 DOS</h1><p>好吧，这其实算不上真正的“UI层”，因为我还没在Windows 10中发现Windows 95以前的任何界面元素（尽管我感觉肯定有）。然而，在Windows 10中有一个奇特的文件，叫做 moricons.dll，它包含了很多DOS时代的老图标。</p><p><img src="https://upload.ismdeep.com/images/2021/06/22/3e17843443b9c99c79124e433af3280f-1df35e.png" alt="mori-1"></p><p>嗯，这么多就是这样。可能你也知道了，微软正计划用他们的“太阳谷”更新来彻底重构Windows系统的用户界面，目的是统一操作系统的设计。然而，正如我们今天所看到的，Windows是一个庞大的操作系统。他们为最终形成一个统一的用户体验所做的努力会成功吗？让我们拭目以待吧。</p><p>谢谢您的关注。</p><hr><p>翻译自：<a href="https://ntdotdev.wordpress.com/2021/02/06/state-of-the-windows-how-many-layers-of-ui-inconsistencies-are-in-windows-10/" target="_blank" rel="noopener">https://ntdotdev.wordpress.com/2021/02/06/state-of-the-windows-how-many-layers-of-ui-inconsistencies-are-in-windows-10/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们可能都听说过这个梗：如果你在Windows 10中挖掘得足够深，你会发现可以追溯到Windows 3.x时代的元素。但这实际上是真的吗？在这篇文章中，我们将来探寻Windows中到底有多少个UI层，以及它们是何时被首次引入的。&lt;/p&gt;
&lt;p&gt;为了这个实验的目的，我选择了
      
    
    </summary>
    
    
      <category term="Windows" scheme="https://ismdeep.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Generate SSH Keys with Docker</title>
    <link href="https://ismdeep.com/posts/2021-05-08-generate-ssh-keys-with-docker.html"/>
    <id>https://ismdeep.com/posts/2021-05-08-generate-ssh-keys-with-docker.html</id>
    <published>2021-05-08T15:06:16.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>An easy and clean way to generate ssh keys with docker.</p><a id="more"></a><h1 id="1-Create-a-Folder-to-Store-SSH-Key"><a href="#1-Create-a-Folder-to-Store-SSH-Key" class="headerlink" title="1. Create a Folder to Store SSH Key"></a>1. Create a Folder to Store SSH Key</h1><pre><code class="bash"># ismdeep @ NSA in ~/Desktop [15:08:46]$ mkdir keys-data# ismdeep @ NSA in ~/Desktop [15:08:57]$ cd keys-data# ismdeep @ NSA in ~/Desktop/keys-data [15:09:00]$ pwd/Users/ismdeep/Desktop/keys-data</code></pre><h1 id="2-Generate-SSH-key"><a href="#2-Generate-SSH-key" class="headerlink" title="2. Generate SSH key"></a>2. Generate SSH key</h1><pre><code class="bash">docker run --rm \    -v /Users/ismdeep/Desktop/keys-data:/keys \    -it ismdeep/ssh-keygen \    /usr/bin/ssh-keygen -t rsa -C &quot;L. Jiang&quot; -f /keys/ljiang1024 -q -N &quot;&quot;</code></pre><h1 id="3-Generate-More-Secure-Keys"><a href="#3-Generate-More-Secure-Keys" class="headerlink" title="3. Generate More Secure Keys"></a>3. Generate More Secure Keys</h1><pre><code class="bash">docker run --rm \    -v /Users/ismdeep/Desktop/keys-data:/keys \    -it ismdeep/ssh-keygen \    /usr/bin/ssh-keygen -t rsa -b 4096 -C &quot;L. Jiang&quot; -f /keys/ljiang1024 -q -N &quot;&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;An easy and clean way to generate ssh keys with docker.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://ismdeep.com/tags/Linux/"/>
    
      <category term="Docker" scheme="https://ismdeep.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库设计规范</title>
    <link href="https://ismdeep.com/posts/2021-03-05-mysql-db-design-guide.html"/>
    <id>https://ismdeep.com/posts/2021-03-05-mysql-db-design-guide.html</id>
    <published>2021-03-05T10:52:12.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述使用MySQL数据库进行开发时，数据库设计的相关规范。</p><a id="more"></a><h1 id="1-规范背景与目的"><a href="#1-规范背景与目的" class="headerlink" title="1. 规范背景与目的"></a>1. 规范背景与目的</h1><p>MySQL数据库与 Oracle、 SQL Server 等数据库相比，有其内核上的优势与劣势。我们在使用MySQL数据库的时候需要遵循一定规范，扬长避短。本规范旨在帮助或指导RD、QA、OP等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL编写等方面予以规范，从而为公司业务系统稳定、健康地运行提供保障。</p><h1 id="2-设计规范"><a href="#2-设计规范" class="headerlink" title="2. 设计规范"></a>2. 设计规范</h1><h2 id="2-1-数据库设计"><a href="#2-1-数据库设计" class="headerlink" title="2.1 数据库设计"></a>2.1 数据库设计</h2><p>以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低。</p><p>对于不满足【高危】和【强制】两个级别的设计，DBA会强制打回要求修改。</p><h3 id="2-1-1-库名"><a href="#2-1-1-库名" class="headerlink" title="2.1.1 库名"></a>2.1.1 库名</h3><ol><li>【强制】库的名称必须控制在32个字符以内，相关模块的表名与表名之间尽量提现join的关系，如user表和user_login表。</li><li>【强制】库的名称格式：业务系统名称_子系统名，同一模块使用的表名尽量使用统一前缀。</li><li>【强制】一般分库名称命名格式是<code>库通配名_编号</code>，编号从0开始递增，比如<code>wenda_001</code>以时间进行分库的名称格式是“库通配名_时间”</li><li>【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：<code>create database db1 default character set utf8;</code>。</li></ol><h3 id="2-1-2-表结构"><a href="#2-1-2-表结构" class="headerlink" title="2.1.2 表结构"></a>2.1.2 表结构</h3><ol><li>【强制】表和列的名称必须控制在32个字符以内，表名只能使用字母、数字和下划线，一律小写。</li><li>【强制】表名要求模块名强相关，如师资系统采用”sz”作为前缀，渠道系统采用”qd”作为前缀等。</li><li>【强制】创建表时必须显式指定字符集为utf8或utf8mb4。</li><li>【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为InnoDB。当需要使用除InnoDB/MyISAM/Memory以外的存储引擎时，必须通过DBA审核才能在生产环境中使用。因为Innodb表支持事务、行锁、宕机恢复、MVCC等关系型数据库重要特性，为业界使用最多的MySQL存储引擎。而这是其他大多数存储引擎不具备的，因此首推InnoDB。</li><li>【强制】建表必须有comment</li><li>【建议】建表时关于主键：(1)强制要求主键为id，类型为int或bigint，且为<code>auto_increment(2)</code>标识表里每一行主体的字段不要设为主键，建议设为其他字段如<code>user_id</code>，<code>order_id</code>等，并建立unique key索引（可参考<code>cdb.teacher</code>表设计）。因为如果设为主键且主键值为随机插入，则会导致innodb内部page分裂和大量随机I/O，性能下降。</li><li>【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段<code>create_time</code>和最后更新时间字段<code>update_time</code>，便于查问题。</li><li>【建议】表中所有字段必须都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT</code>值。因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</li><li>【建议】建议对表里的<code>blob</code>、<code>text</code>等大字段，垂直拆分到其他表里，仅在需要读这些对象的时候才去select。</li><li>【建议】反范式设计：把经常需要join查询的字段，在其他表里冗余一份。如<code>user_name</code>属性在<code>user_account</code>，<code>user_login_log</code>等表里冗余一份，减少join查询。</li><li>【强制】中间表用于保留中间结果集，名称必须以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称必须以<code>bak_</code>开头。中间表和备份表定期清理。</li><li>【强制】对于超过100W行的大表进行<code>alter table</code>，必须经过DBA审核，并在业务低峰期执行。因为<code>alter table</code>会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</li></ol><h3 id="2-1-3-列数据类型优化"><a href="#2-1-3-列数据类型优化" class="headerlink" title="2.1.3 列数据类型优化"></a>2.1.3 列数据类型优化</h3><ol><li>【建议】表中的自增列（<code>auto_increment</code>属性），推荐使用<code>bigint</code>类型。因为无符号<code>int</code>存储范围为<code>-2147483648~2147483647</code>（大约21亿左右），溢出后会导致报错。</li><li>【建议】业务中选择性很少的状态<code>status</code>、类型<code>type</code>等字段推荐使用<code>tinytint</code>或者<code>smallint</code>类型节省存储空间。</li><li>【建议】业务中IP地址字段推荐使用<code>int</code>类型，不推荐用<code>char(15)</code>。因为<code>int</code>只占4字节，可以用如下函数相互转换，而<code>char(15)</code>占用至少15字节。一旦表数据行数到了1亿，那么要多用1.1G存储空间。 SQL：<code>select inet_aton(&#39;192.168.2.12&#39;); select inet_ntoa(3232236044);</code> PHP: <code>ip2long(‘192.168.2.12’); long2ip(3530427185);</code></li><li>【建议】不推荐使用<code>enum</code>，<code>set</code>。 因为它们浪费空间，且枚举值写死了，变更不方便。推荐使用<code>tinyint</code>或<code>smallint</code>。</li><li>【建议】不推荐使用<code>blob</code>，<code>text</code>等类型。它们都比较浪费硬盘和内存空间。在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。建议和PM、RD沟通，是否真的需要这么大字段。Innodb中当一行记录超过8098字节时，会将该记录中选取最长的一个字段将其768字节放在原始page里，该字段余下内容放在<code>overflow-page</code>里。不幸的是在<code>compact</code>行格式下，原始<code>page</code>和<code>overflow-page</code>都会加载。</li><li>【建议】存储金钱的字段，建议用<code>int</code>，程序端乘以100和除以100进行存取。因为<code>int</code>占用4字节，而<code>double</code>占用8字节，空间浪费。</li><li>【建议】文本数据尽量用<code>varchar</code>存储。因为<code>varchar</code>是变长存储，比<code>char</code>更省空间。MySQL server层规定一行所有文本最多存65535字节，因此在utf8字符集下最多存21844个字符，超过会自动转换为<code>mediumtext</code>字段。而<code>text</code>在utf8字符集下最多存21844个字符，<code>mediumtext</code>最多存2^24/3个字符，<code>longtext</code>最多存2^32个字符。一般建议用<code>varchar</code>类型，字符数不要超过2700。</li><li>【建议】时间类型尽量选取<code>timestamp</code>。因为<code>datetime</code>占用8字节，<code>timestamp</code>仅占用4字节，但是范围为<code>1970-01-01 00:00:01</code>到<code>2038-01-01 00:00:00</code>。更为高阶的方法，选用<code>int</code>来存储时间，使用SQL函数<code>unix_timestamp()</code>和<code>from_unixtime()</code>来进行转换。</li></ol><p>详细存储大小参加下图：</p><p><a href="https://github.com/kylexlau/archer/raw/master/sql/static/pics/mysql_datatype.png" target="_blank" rel="noopener"><img src="https://github.com/kylexlau/archer/raw/master/sql/static/pics/mysql_datatype.png" alt="MySQL数据类型存储大小"></a></p><h3 id="2-1-4-索引设计"><a href="#2-1-4-索引设计" class="headerlink" title="2.1.4 索引设计"></a>2.1.4 索引设计</h3><ol><li>【强制】InnoDB表必须主键为<code>id int/bigint auto_increment</code>,且主键值禁止被更新。</li><li>【建议】主键的名称以“<code>pk_</code>”开头，唯一键以“<code>uk_</code>”或“<code>uq_</code>”开头，普通索引以“<code>idx_</code>”开头，一律使用小写格式，以表名/字段的名称或缩写作为后缀。</li><li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>；MEMORY表可以根据需要选择<code>HASH</code>或者<code>BTREE</code>类型索引。</li><li>【强制】单个索引中每个索引记录的长度不能超过64KB。</li><li>【建议】单个表上的索引个数不能超过7个。</li><li>【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。如列<code>userid</code>的区分度可由<code>select count(distinct userid)</code>计算出来。</li><li>【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高。</li><li>【建议】建表或加索引时，保证表里互相不存在冗余索引。对于MySQL来说，如果表里已经存在<code>key(a,b)</code>，则<code>key(a)</code>为冗余索引，需要删除。</li></ol><h3 id="2-1-5-分库分表、分区表"><a href="#2-1-5-分库分表、分区表" class="headerlink" title="2.1.5 分库分表、分区表"></a>2.1.5 分库分表、分区表</h3><ol><li>【强制】分区表的分区字段（<code>partition-key</code>）必须有索引，或者是组合索引的首列。</li><li>【强制】单个分区表中的分区（包括子分区）个数不能超过1024。</li><li>【强制】上线前RD或者DBA必须指定分区表的创建、清理策略。</li><li>【强制】访问分区表的SQL必须包含分区键。</li><li>【建议】单个分区文件不超过2G，总大小不超过50G。建议总分区数不超过20个。</li><li>【强制】对于分区表执行<code>alter table</code>操作，必须在业务低峰期执行。</li><li>【强制】采用分库策略的，库的数量不能超过1024</li><li>【强制】采用分表策略的，表的数量不能超过4096</li><li>【建议】单个分表不超过500W行，ibd文件大小不超过2G，这样才能让数据分布式变得性能更佳。</li><li>【建议】水平分表尽量用取模方式，日志、报表类数据建议采用日期进行分表。</li></ol><h3 id="2-1-6-字符集"><a href="#2-1-6-字符集" class="headerlink" title="2.1.6 字符集"></a>2.1.6 字符集</h3><ol><li>【强制】数据库本身库、表、列所有字符集必须保持一致，为<code>utf8</code>或<code>utf8mb4</code>。</li><li>【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为<code>utf8</code>。</li></ol><h3 id="2-1-7-程序层DAO设计建议"><a href="#2-1-7-程序层DAO设计建议" class="headerlink" title="2.1.7 程序层DAO设计建议"></a>2.1.7 程序层DAO设计建议</h3><ol><li>【建议】新的代码不要用model，推荐使用手动拼SQL+绑定变量传入参数的方式。因为model虽然可以使用面向对象的方式操作db，但是其使用不当很容易造成生成的SQL非常复杂，且model层自己做的强制类型转换性能较差，最终导致数据库性能下降。</li><li>【建议】前端程序连接MySQL或者redis，必须要有连接超时和失败重连机制，且失败重试必须有间隔时间。</li><li>【建议】前端程序报错里尽量能够提示MySQL或redis原生态的报错信息，便于排查错误。</li><li>【建议】对于有连接池的前端程序，必须根据业务需要配置初始、最小、最大连接数，超时时间以及连接回收机制，否则会耗尽数据库连接资源，造成线上事故。</li><li>【建议】对于log或history类型的表，随时间增长容易越来越大，因此上线前RD或者DBA必须建立表数据清理或归档方案。</li><li>【建议】在应用程序设计阶段，RD必须考虑并规避数据库中主从延迟对于业务的影响。尽量避免从库短时延迟（20秒以内）对业务造成影响，建议强制一致性的读开启事务走主库，或更新后过一段时间再去读从库。</li><li>【建议】多个并发业务逻辑访问同一块数据（innodb表）时，会在数据库端产生行锁甚至表锁导致并发下降，因此建议更新类SQL尽量基于主键去更新。</li><li>【建议】业务逻辑之间加锁顺序尽量保持一致，否则会导致死锁。</li><li>【建议】对于单表读写比大于10:1的数据行或单个列，可以将热点数据放在缓存里（如mecache或redis），加快访问速度，降低MySQL压力。</li></ol><h3 id="2-1-8-一个规范的建表语句示例"><a href="#2-1-8-一个规范的建表语句示例" class="headerlink" title="2.1.8 一个规范的建表语句示例"></a>2.1.8 一个规范的建表语句示例</h3><p>一个较为规范的建表语句为：</p><pre><code>CREATE TABLE user (  `id` bigint(11) NOT NULL AUTO_INCREMENT,  `user_id` bigint(11) NOT NULL COMMENT ‘用户id’  `username` varchar(45) NOT NULL COMMENT &#39;真实姓名&#39;,  `email` varchar(30) NOT NULL COMMENT ‘用户邮箱’,  `nickname` varchar(45) NOT NULL COMMENT &#39;昵称&#39;,  `avatar` int(11) NOT NULL COMMENT &#39;头像&#39;,  `birthday` date NOT NULL COMMENT &#39;生日&#39;,  `sex` tinyint(4) DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;,  `short_introduce` varchar(150) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多50个汉字&#39;,  `user_resume` varchar(300) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;,  `user_register_ip` int NOT NULL COMMENT ‘用户注册时的源ip’,  `create_time` timestamp NOT NULL COMMENT ‘用户记录创建的时间’,  `update_time` timestamp NOT NULL COMMENT ‘用户资料修改的时间’,  `user_review_status` tinyint NOT NULL COMMENT ‘用户资料审核状态，1为通过，2为审核中，3为未通过，4为还未提交审核’,  PRIMARY KEY (`id`),  UNIQUE KEY `idx_user_id` (`user_id`),  KEY `idx_username`(`username`),  KEY `idx_create_time`(`create_time`,`user_review_status`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;网站用户基本信息&#39;;</code></pre><h2 id="2-2-SQL编写"><a href="#2-2-SQL编写" class="headerlink" title="2.2 SQL编写"></a>2.2 SQL编写</h2><h3 id="2-2-1-DML语句"><a href="#2-2-1-DML语句" class="headerlink" title="2.2.1 DML语句"></a>2.2.1 DML语句</h3><ol><li>【强制】SELECT语句必须指定具体字段名称，禁止写成<code>*</code>。因为<code>select *</code>会将不该读的数据也从MySQL里读出来，造成网卡压力。且表字段一旦更新，但model层没有来得及更新的话，系统会报错。</li><li>【强制】insert语句指定具体字段名称，不要写成<code>insert into t1 values(…)</code>，道理同上。</li><li>【建议】<code>insert into…values(XX),(XX),(XX)…</code>。这里XX的值不要超过5000个。值过多虽然上线很很快，但会引起主从同步延迟。</li><li>【建议】SELECT语句不要使用<code>UNION</code>，推荐使用<code>UNION ALL</code>，并且<code>UNION</code>子句个数限制在5个以内。因为<code>union all</code>不需要去重，节省数据库资源，提高性能。</li><li>【建议】in值列表限制在500以内。例如<code>select… where userid in(….500个以内…)</code>，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。</li><li>【建议】事务里批量更新数据需要控制数量，进行必要的sleep，做到少量多次。</li><li>【强制】事务涉及的表必须全部是innodb表。否则一旦失败不会全部回滚，且易造成主从库同步终端。</li><li>【强制】写入和事务发往主库，只读SQL发往从库。</li><li>【强制】除静态表或小表（100行以内），DML语句必须有where条件，且使用索引查找。</li><li>【强制】生产环境禁止使用<code>hint</code>，如<code>sql_no_cache</code>，<code>force index</code>，<code>ignore key</code>，<code>straight join</code>等。因为<code>hint</code>是用来强制SQL按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，因此我们要相信MySQL优化器！</li><li>【强制】where条件里等号左右字段类型必须一致，否则无法利用索引。</li><li>【建议】<code>SELECT|UPDATE|DELETE|REPLACE</code>要有WHERE子句，且WHERE子句的条件必需使用索引查找。</li><li>【强制】生产数据库中强烈不推荐大表上发生全表扫描，但对于100行以下的静态表可以全表扫描。查询数据量不要超过表行数的25%，否则不会利用索引。</li><li>【强制】WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，必须有其他等值或范围查询条件，否则无法利用索引。</li><li>【建议】索引列不要使用函数或表达式，否则无法利用索引。如<code>where length(name)=&#39;Admin&#39;</code>或<code>where user_id+2=10023</code>。</li><li>【建议】减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如<code>where a=1 or b=2</code>优化为<code>where a=1… union …where b=2, key(a),key(b)</code>。</li><li>【建议】分页查询，当limit起点较高时，可先用过滤条件进行过滤。如<code>select a,b,c from t1 limit 10000,20;</code>优化为: <code>select a,b,c from t1 where id&gt;10000 limit 20;</code>。</li></ol><h3 id="2-2-2-多表连接"><a href="#2-2-2-多表连接" class="headerlink" title="2.2.2 多表连接"></a>2.2.2 多表连接</h3><ol><li>【强制】禁止跨db的join语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础。</li><li>【强制】禁止在业务的更新类SQL语句中使用join，比如<code>update t1 join t2…</code>。</li><li>【建议】不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询。</li><li>【建议】线上环境，多表join不要超过3个表。</li><li>【建议】多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如<code>select a from db1.table1 alias1 where …</code>。</li><li>【建议】在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表。</li></ol><h3 id="2-2-3-事务"><a href="#2-2-3-事务" class="headerlink" title="2.2.3 事务"></a>2.2.3 事务</h3><ol><li>【建议】事务中<code>INSERT|UPDATE|DELETE|REPLACE</code>语句操作的行数控制在2000以内，以及WHERE子句中IN列表的传参个数控制在500以内。</li><li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep，一般建议值5-10秒。</li><li>【建议】对于有<code>auto_increment</code>属性字段的表的插入操作，并发需要控制在200以内。</li><li>【强制】程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。线上建议事务隔离级别为<code>repeatable-read</code>。</li><li>【建议】事务里包含SQL不超过5个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题。</li><li>【建议】事务里更新语句尽量基于主键或<code>unique key</code>，如<code>update … where id=XX</code>; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li><li>【建议】尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长。</li><li>【建议】对于MySQL主从延迟严格敏感的select语句，请开启事务强制访问主库。</li></ol><h3 id="2-2-4-排序和分组"><a href="#2-2-4-排序和分组" class="headerlink" title="2.2.4 排序和分组"></a>2.2.4 排序和分组</h3><ol><li>【建议】减少使用<code>order by</code>，和业务沟通能不排序就不排序，或将排序放到程序端去做。<code>order by</code>、<code>group by</code>、<code>distinct</code>这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>【建议】<code>order by</code>、<code>group by</code>、<code>distinct</code>这些SQL尽量利用索引直接检索出排序好的数据。如<code>where a=1 order by</code>可以利用<code>key(a,b)</code>。</li><li>【建议】包含了<code>order by</code>、<code>group by</code>、<code>distinct</code>这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ol><h3 id="2-2-5-线上禁止使用的SQL语句"><a href="#2-2-5-线上禁止使用的SQL语句" class="headerlink" title="2.2.5 线上禁止使用的SQL语句"></a>2.2.5 线上禁止使用的SQL语句</h3><ol><li>【高危】禁用<code>update|delete t1 … where a=XX limit XX;</code> 这种带limit的更新语句。因为会导致主从不一致，导致数据错乱。建议加上<code>order by PK</code>。</li><li>【高危】禁止使用关联子查询，如<code>update t1 set … where name in(select name from user where…);</code>效率极其低下。</li><li>【强制】禁用procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现。</li><li>【强制】禁用<code>insert into …on duplicate key update…</code>在高并发环境下，会造成主从不一致。</li><li>【强制】禁止联表更新语句，如<code>update t1,t2 where t1.id=t2.id…</code>。</li></ol><p>转载自：<a href="https://github.com/jly8866/archer/blob/master/src/docs/mysql_db_design_guide.md" target="_blank" rel="noopener">https://github.com/jly8866/archer/blob/master/src/docs/mysql_db_design_guide.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲述使用MySQL数据库进行开发时，数据库设计的相关规范。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://ismdeep.com/tags/MySQL/"/>
    
      <category term="Development" scheme="https://ismdeep.com/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>打开 Word 文档后，电脑就特别卡</title>
    <link href="https://ismdeep.com/posts/2021-02-25-after-open-word-cpu-burning.html"/>
    <id>https://ismdeep.com/posts/2021-02-25-after-open-word-cpu-burning.html</id>
    <published>2021-02-25T15:33:00.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>打开Word文档后，电脑就变得特别卡，文档根本没法编辑，CPU占用率居高不下，有时候虽然现实只有50%或者25%，这是因为占用了某个单核，而如果CPU是4核的，那占用率就是25%了。</p><p>那么出现这样的问题的原因是什么呢？大致上就是因为以下两种情况：</p><ul><li>启用了单词拼写检查功能。</li><li>启用了智能标记功能。</li></ul><p>Word是默认启用这两项功能的。在设置里面关闭即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开Word文档后，电脑就变得特别卡，文档根本没法编辑，CPU占用率居高不下，有时候虽然现实只有50%或者25%，这是因为占用了某个单核，而如果CPU是4核的，那占用率就是25%了。&lt;/p&gt;
&lt;p&gt;那么出现这样的问题的原因是什么呢？大致上就是因为以下两种情况：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
      <category term="Windows" scheme="https://ismdeep.com/tags/Windows/"/>
    
      <category term="Office" scheme="https://ismdeep.com/tags/Office/"/>
    
      <category term="Word" scheme="https://ismdeep.com/tags/Word/"/>
    
  </entry>
  
  <entry>
    <title>软件开发经验之谈</title>
    <link href="https://ismdeep.com/posts/2021-02-19-software-development-rules-of-thumb.html"/>
    <id>https://ismdeep.com/posts/2021-02-19-software-development-rules-of-thumb.html</id>
    <published>2021-02-19T20:54:08.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>在我的软件开发生涯中，我形成了一些个人的经验法则，这些经验法则可以帮助我更好地编写代码，写出可读性和可维护更强的代码。</p><p>但首先，什么是经验法则？对我来说，它是我采用的一个原则，当我一次又一次地应用它时，它积极地帮助我实现我的目标。这些目标可能不同：从代码质量，到软件架构，但每次都是与代码的可维护性有关。</p><p>让我们直接开始吧。</p><h1 id="1-命名：传达意图（而非实现细节）"><a href="#1-命名：传达意图（而非实现细节）" class="headerlink" title="1. 命名：传达意图（而非实现细节）"></a>1. 命名：传达意图（而非实现细节）</h1><p>这是我遵循的一个核心经验法则，它总是会带来更好的代码。几乎在所有情况下，当我们写代码时，我们都会处理业务逻辑。这个业务逻辑处理的是我们要实现的核心问题，所以代码应该始终反映这一点。</p><p>当我们给一个变量命名时，应该反映出它所代表的内容，而不是说它是一个列表或者是其中有一些什么数据类型。</p><p>在写一个业务逻辑块的时候，你希望下一个最终从事这个工作的人能够弄清楚问题的核心。当一个需求进来的时候，它肯定会要求一些业务逻辑的实现或变更，使用的是其数据域的特定术语。</p><p>当我们写出这个逻辑的时候，用同样的语言进行转写和改编，就会容易很多。</p><p>对于一个在同一个项目（或项目的一部分）上工作的团队来说，领域语言是所有成员共享的，而具体的实现术语可能会有所不同，并造成混乱。有的人会喜欢<em>array</em>，有的人会喜欢<em>list</em>，有的人会喜欢<em>vector</em>，有的人会喜欢<em>iterable</em>。但是当你谈到业务逻辑时，一组集合对大家的意义是一样的。</p><p>所以，这样写</p><pre><code>collection_ids = [1, 2, 3, 4]</code></pre><p>总是比这样写更好</p><pre><code>list_of_ints = [1, 2, 3, 4]</code></pre><p>同样的原则也适用于类、方法和函数的命名。一个类的目的应该尽可能的明显，应该不惜一切代价避免包含数据或处理器的命名。</p><h1 id="2-类和函数应该只做一件事情，而且只做一件事情。"><a href="#2-类和函数应该只做一件事情，而且只做一件事情。" class="headerlink" title="2. 类和函数应该只做一件事情，而且只做一件事情。"></a>2. 类和函数应该只做一件事情，而且只做一件事情。</h1><p>虽然这是一个从大学一年级就开始思考的面向对象编程的流行概念，但我看到外面有太多的课，什么都做。这还是比有一个巨大的文件，里面只有互相调用的函数，而且每次都互相传递同样的3-4个参数要好，但这不是一个足够好的方法。</p><p>当一个类/函数只有一个责任时，它的可测试性更强，可以更容易重构，在某些情况下，还可以重用。这些都会提高代码库的整体代码质量，进而提高开发速度。</p><p>举个简单的例子，像下面这样的类就做得太多了。</p><pre><code class="python">class FileExporter:  def to_xml(self, ...):    ...  def to_json(self, ...):    ...  def to_xlsx(self, ...):    ...</code></pre><p>最好为我们要做的每一个操作以单独的类。</p><pre><code class="python">class XmlExporter:    def export(self):        passclass JsonExporter:    def export(self):        passclass XlsxExporter:    def export(self):        pass</code></pre><p>This way, we can test each functionality independently, and we can differentiate easier between them. Some the exporter will require/support extra configuration the others will not: the <code>ExcelExporter</code> would allow formatting, exporting to multiple sheets, data validation, etc… while the <code>XmlExporter</code> would allow specifying the <code>xmlns</code>, a thing that is very specific to the implemented file format.</p><p>这样一来，我们就可以独立地测试每一个功能，而且我们可以更容易地区分它们。有些导出器需要/支持额外的配置，而其他的则不需要：<code>ExcelExporter</code> 允许格式化，导出到多个工作表，数据验证等……而 <code>XmlExporter</code> 允许指定 <code>xmlns</code> ，这是一个非常具体的实现文件格式的东西。</p><h1 id="3-K-I-S-S-你不需要它"><a href="#3-K-I-S-S-你不需要它" class="headerlink" title="3. K.I.S.S / 你不需要它"></a>3. K.I.S.S / 你不需要它</h1><p>另外两个非常流行的 OOP 原则，我喜欢为了简单而合并成一个规则，就是 K.I.S.S. 和 Y.A.G.N.I.</p><p>归根结底就是避免过早的优化，一次次重构，直到你得到完美的抽象（提示：完美的抽象并不存在），实现功能只是为了以防将来需要。</p><p>每次写代码的时候，你的首要任务是用足够好的代码实现功能。完美的代码是不存在的，所以你必须满足于下一个最好的东西：足够好。你仍然必须生产出质量好的代码，但纠结于变量和类的命名不应该是你的主要优先事项。</p><p>代码总是可以在以后进行重构，但功能才是最重要的，因为代码是用来解决问题的。</p><h1 id="4-解耦，解耦，解耦"><a href="#4-解耦，解耦，解耦" class="headerlink" title="4. 解耦，解耦，解耦"></a>4. 解耦，解耦，解耦</h1><p>让事情尽可能的解耦，是一个人能做出的最好的实现决策。这将使你更容易重构，在需要的时候可以换掉不同的功能，测试所有的东西，而不需要过多的嘲讽和头疼。</p><p>我发现，一个好的设计模式可以帮助你解耦组件，就是适配器模式。虽然它不应该被滥用，但它对于并行开发两个独立的组件，然后用一个额外的轻量级层与适配器集成它们，使它们的输入/输出兼容是很有用的。</p><h1 id="5-单一代码库，多种环境"><a href="#5-单一代码库，多种环境" class="headerlink" title="5. 单一代码库，多种环境"></a>5. 单一代码库，多种环境</h1><p>虽然这是现在的常识，但一些老的架构和部署策略仍然在代码库层面对环境进行了区分。</p><p>每个环境的代码库应该始终是相同的，因为这样可以更容易地将生产错误复制到开发环境的本地。环境负责为每个环境提供配置，并对生产、暂存和开发进行区分。</p><p>我个人比较喜欢通过环境变量来配置项目，但也有其他方法可以达到同样的效果：配置文件、集中参数存储等。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>我不认为有什么结论可以拿来总结的，因为毕竟这篇文章只是我个人的一些原则。希望你能喜欢！</p><p>Repost from: <a href="https://vladcalin.ro/blog/2021-01-30-software-development-rules-of-thumb" target="_blank" rel="noopener">https://vladcalin.ro/blog/2021-01-30-software-development-rules-of-thumb</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我的软件开发生涯中，我形成了一些个人的经验法则，这些经验法则可以帮助我更好地编写代码，写出可读性和可维护更强的代码。&lt;/p&gt;
&lt;p&gt;但首先，什么是经验法则？对我来说，它是我采用的一个原则，当我一次又一次地应用它时，它积极地帮助我实现我的目标。这些目标可能不同：从代码质量，
      
    
    </summary>
    
    
      <category term="Development" scheme="https://ismdeep.com/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>通过实践来学习编程</title>
    <link href="https://ismdeep.com/posts/2021-02-18-learn-to-code-by-doing.html"/>
    <id>https://ismdeep.com/posts/2021-02-18-learn-to-code-by-doing.html</id>
    <published>2021-02-18T19:55:33.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>即使认为这基本上是大家在成长过程中最常说的一句话，但我看到大多数人还是没有“学会”。当他们开始学习新的东西时，他们的第一直觉就是抓一大堆教程和书籍，仅此而已。这篇文章主要是针对软件开发工程师的，我见过太多人太多次迷失在教程的炼狱里，花了太多时间和精力去“学习”。</p><p>那么，实际问题是什么呢？当你在学习一门新的技术或者完全开始技术生涯的时候，看一些教程没什么问题。但教程只会耗费你更多的时间，会教给你一套非常有限的指令，而这些指令在实际的场景中可能并不会有任何意义。</p><p>从零开始构建一个应用程序会涉及到很多部件，这些部件通常并不会出现在这些教程中。教程往往只涉及表面。</p><h2 id="教程炼狱"><a href="#教程炼狱" class="headerlink" title="教程炼狱"></a>教程炼狱</h2><p>我见过很多初学者都掉进了教程炼狱这个陷阱。一开始，他们不知道该学什么，因为要成为一名软件开发人员，你需要掌握很多学科的知识。</p><p>于是，他们就在谷歌上搜索“随机编程语言教程”来开始学习一些东西。他们就会挑选一些基础知识来看。然后他们搜索更多的教程。然后就跟着教程做。通过完成每一个教程感受到了多巴胺的刺激。觉得自己也蛮聪明的，感觉自己进步了。</p><p>但是在完成了一些教程之后，实际的学习就停止了。然而他们还是继续去搜教程，不断从不同的学习平台去购买教程，并陷入不断的一个又一个的教程中。</p><p>这就是<strong>教程炼狱</strong>。新手很容易掉入的心理陷阱。他们从教程中反复学习同样的东西，殊不知他们缺失了该有的成长。同样的概念以不同的形式出现，给人以进步的错觉。</p><p>教程是不够的。这些教程足以让你跟着开始并构建一些非常具体的作者想要的东西，给你一个明确的步骤清单，你跟着做就行。在最后，你也完成了课程，并且构建出了作者希望你构建的东西。然而实际上，并没有真正构建起任何的东西。</p><p>要想挣脱束缚，该怎么做呢？在我看来，软件工程远不止写代码这么简单。当然，对很多人来说，写代码这个职业已经是一个不错的选择，但如果你只知道写代码，那么一段时间后就会停止发展。</p><p>软件开发是建立问题的解决方案、分析问题、将其分解成步骤、建立算法、给出所需的结果并交付可用的东西。</p><h2 id="软件开发者需要知道什么？"><a href="#软件开发者需要知道什么？" class="headerlink" title="软件开发者需要知道什么？"></a>软件开发者需要知道什么？</h2><p>这还真不好说，这与每个人的看法有关。每个人的经历不同，对这个问题的看法也就会不一样。有时候也会产生关于数学是否有用的分歧。在我看来，一个成功的软件工程师，应该对大多数与计算机相关的领域都有一个大概的了解，这样才能看清和了解全局，并围绕全局展开工作。</p><p>最关键的领域有：</p><ul><li><p><strong>数学</strong> —— 是的，一个有点不受欢迎的观点，但是我认为数学是软件开发中的一个关键部分。并不是因为公式和微积分可能会帮你构建 web 应用，而是你在学数学时培养的批判性思维和结构性思维对你如何处理问题至关重要。从某种程序上来看，数学就是将需要解决更大的问题，分解成更小的更容易解决的问题，并将结果结合起来。这基本上就是：发明、遵循并结合算法。</p><p><em>如何学习？</em></p><p>嗯，答案可能不会让你感到惊讶：做数学题。还记得那些你没有做或者试图逃避做的数学作业吗？当你的大脑大部分时间都设置在学习模式时，所有这些都会有助于建立你的算法思维。现在应该还是这样，但现在你的时间和精力比较有限。</p><p>软件工程最难接受的是，其实你必须在一定程度上喜欢数学，才能在工作中取得成功，或者对解决问题充满热情。如果不是这样，软件工程可能不是最好的职业选择，你最终要么会被炒掉，要么就会讨厌你的工作。</p></li><li><p><strong>低级编程语言</strong> —— 基本上就是对 C/C++ 的了解。什么是编译，什么是内存管理，什么是文件描述符管理，甚至是一些汇编的知识都会很有用。掌握这方面的一些知识，当你看到你正在构建的代码时，肯定会帮助你调试和发现问题。例如，如果你不知道要找什么，内存泄漏就很难修复。如果你有一些低级编程的知识，你就会知道，你必须四处寻找未释放的内存，陈旧的引用，防止一些数据结构从内存中删除，或者未关闭的文件描述符。</p><p><em>如何学习？</em></p><p>实际学习和用 C/C++ 构建小程序。必须处理分配内存的实际案例场景，并注意非法内存访问和与指针的工作，肯定会让你学到很多东西。潜心研究一下汇编也许是值得的，因为你会看到处理器看到的代码，而不是你写的代码，你最终会明白，你写的所有东西对处理器来说都变成了一堆的指令（比如移动数据，管理执行指针，以及一直从堆栈中推送和弹出东西）。</p></li><li><p><strong>操作系统</strong> —— 因为每一段代码都是在操作系统上运行的，你在电脑上度过的每一刻，基本上都是在使用操作系统，所以了解你所处理的东西至关重要。磁盘、文件、目录是如何工作的？什么是用户，程序突然关闭是什么意思，突然风扇开始吹热风，发出很大的噪音是什么意思？你会从哪里收集更多的信息？</p><p><em>如何学习？</em></p><p>这里就比较棘手了。没有正确的方法来解决，它，但有一些选择，肯定会让你更容易。学习操作系统最有影响的方法是上 Linux，开始用C语言实现你在Linux中找到的基本命令：cd、ls、mkdir、ps等。重新发明轮子是比打造原创性的东西更好的学习体验。</p></li><li><p><strong>网络</strong> —— 虽然是一个很难的话题，但在当前的软件开发环境下，了解进程如何通信是至关重要的。单一服务器上的单一应用的时代已经结束，云计算的时代已经到来。你需要知道这些移动的部件是如何结合在一起的，最重要的是，它们之间是如何沟通的？经常有人问我，即使是全新的路由器，如何通过内存知道它的地址？联网。在一个软件项目中，你会遇到的很多错误都与网络有关，比如连接一直被关闭，定时出错，被拒绝，搞清楚数据库连接需要什么配置才能工作等等。这些都在于网络领域。</p><p><em>如何学习？</em></p><p>简单的答案和操作系统要点的答案是一样的。构建一些流行的开源应用的客户端，如数据库，电子邮件服务器，甚至SSH，如果你觉得冒险的话。这将提供一个很好的学习经验。</p></li><li><p><strong>设计模式</strong> —— 这是一个你真的不需要学习的话题，因为你会从构建中，随着你的经验越来越多，逐渐学会。学习这种东西最有力的方法就是用错误的方式构建一些东西，完全不使用任何设计模式，然后重构（或从头开始重新构建）来整合它们。看到第一手的例子，了解它们是如何帮助你的代码变得更容易管理的，这将保证对 “为什么 “的深刻理解。而这才是最重要的事情：弄清楚为什么要使用某些设计模式，并认识到它们所解决的问题，这样你就能在问题真正成为问题之前就能得到 “感觉”。</p><p><em>如何学习？</em></p><p>靠经验和耐心。你会犯错误。每个人都会犯错。而且这很好。代码不一定要从迭代一开始就完美。一个应用程序/项目永远不会完成，它的代码库会不断变化。每一次变化都应该努力增加功能，或者减少技术债。</p><p>另一种学习设计模式的方法是使用框架和探索开源代码：它们已经融入了良好的实践和设计模式。这对体验这些设计模式的优点和缺点会很有用。</p></li></ul><p>是不是觉得奇怪，怎么这个列表中并没有编程语言？我并不认为懂得一门编程语言是一个软件开发者的关键技能。毕竟，编程语言是我们用来解决问题的工具，而工具是可以切换的。当然，随着时间的推移，我们会对一种工具的使用比其他工具更加熟练，并且会在大部分时间内更喜欢使用某一种语言，并在此基础上建立自己的职业生涯，但它不应该成为定义你职业生涯的东西。最终你需要成长起来，把语言仅仅看作是工具，真正的挑战是整个应用。用任何语言（甚至是PHP）都可以建立伟大的东西。</p><h3 id="在实践中学习"><a href="#在实践中学习" class="headerlink" title="在实践中学习"></a>在实践中学习</h3><p>回到最开始的想法：在实践中学习。从零开始构建一些东西，体验真实开发中会出现的全部问题和挑战，这一点很重要。当你在软件开发行业工作时，你的工作就是在解决真实应用/系统中的实际问题。</p><p>只在工作中学习也有一些非常大的弊端：学习率和探索解决方案的灵活性非常有限，因为有真实的利益关系在里面，人们会监督你的工作，你会被限制在一些有限的资源内，更大的重构环节需要大量的规划，并且会被多人分担，所以知识的获得也是会被分割的。</p><p>要想真正让你的软件开发能力突飞猛进，你应该有一些你自己热衷的个人项目。你应噶在工作时间之外建立一些东西，并把它作为一个允许任何错误并且没有风险的竞争场。你唯一需要投入的资源就是时间，与其把时间浪费在社交媒体上，不如每天花上至少一个小时时间来构建你自己的项目。</p><p>一开始，会很乏味，大多数人放弃这样的学习方法转而拿起教程进行学习的原因就在于此：你从一无所知开始，你需要弄清楚步骤是什么。</p><p>那么，假设你想构建一个 Twitter. 你应该怎么开始？用户？推文？提及？</p><p>这是一个艰难的决定，但这肯定是任何项目开始时都需要作出的决定。在企业环境中，有一整套专门的流程，需要花费大量的时间和人力。</p><p>但作为一个独立开发者，一开始就一头扎进去，边干边想也是可以的。犯错可以创造学习的机会。</p><p>比如，我目前正在构建 <a href="https://amethystplatform.com/" target="_blank" rel="noopener">Amethyst Platform</a> ，我五次重新开始此项目。每一次，我的起点都比之前知道得更多。最终，每一次迭代，都会有更多的进步。</p><p>构建个人项目给了你尝试任何事物的土壤：新技术、新工艺、新设计模式、新架构、新方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我对任何想让自己的职业生涯保持在上升轨道上的软件开发人员的建议就是：拥抱软件开发行业的广阔天地，专注于构建个人项目。</p><p>通过构建自己的东西，我们可以获得新的技能，我们能够无风险地进行试验并犯很多错误，而且没有老板和最后期限的压力。</p><p>为了了解更多的东西，有必要掌握互联网的构件，从运行我们的代码的机器，数据在世界各地的移动方式到我们代码的架构和结构，这样我们就能更容易地驾驭它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;即使认为这基本上是大家在成长过程中最常说的一句话，但我看到大多数人还是没有“学会”。当他们开始学习新的东西时，他们的第一直觉就是抓一大堆教程和书籍，仅此而已。这篇文章主要是针对软件开发工程师的，我见过太多人太多次迷失在教程的炼狱里，花了太多时间和精力去“学习”。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Development" scheme="https://ismdeep.com/tags/Development/"/>
    
      <category term="Study" scheme="https://ismdeep.com/tags/Study/"/>
    
  </entry>
  
  <entry>
    <title>关于区块链（比特币），我想说的其实是……</title>
    <link href="https://ismdeep.com/posts/2021-02-18-my-opinion-on-blockchain.html"/>
    <id>https://ismdeep.com/posts/2021-02-18-my-opinion-on-blockchain.html</id>
    <published>2021-02-18T11:46:58.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客的灵感来自于 Reddit 上的一个问题：你的投资中有多少是加密货币？</p><p>好吧，我的回答是 0% 并且以后也依然是 0%.</p><p>我看不到其价值所在，一堆人鼓吹它，然而这些人都是些伪君子：他们说他们使用加密货币是为了对抗目前被政府控制的 FIAT 系统，同时又白日做梦，想把它卖掉，获得巨大利润（转化成 FIAT 系统中的货币）。每一个拥护者都提倡人们持有加密货币，然而这并不是货币的目的。货币的目的在于：成为交换的媒介与手段。</p><p>另外，我还看到主张基本经济学的人对基本经济学一通胡说：</p><ul><li>他们说通货紧缩而看不到通货膨胀这是一件好事，而实际上却是一件坏事。有理由将几乎所有地方的目标通货膨胀率定在 2% 左右。然而，我们需要通货膨胀来保持经济发展。</li><li>他们说这是一种货币，然而并不是。它并不是每个人都可以接触到的（并不是每个人无时无刻都可以访问互联网的）。</li><li>如果你丢失了密钥，你将永远失去对钱包的访问权限，而这是没有任何人可以帮助你的。然而人们并不太明白这是多么严重的事情。想象一下人们因为一个愚蠢的行为而失去他的一切。</li><li>波动性是任何经济市场的敌人：我们需要稳定的和可预测的货币系统来避免混乱。企业需要可预测性来准备股票；工厂需要可预测性来准备商品；人们需要可预测性来做预算和定制长期计划。当然，长期计划通常跟预期不太一样，但是你应该不想因为一些疯狂的波动（你今一辆车的价格是 0.5 BTC，而明天可能就是 5 BTC 了）而每周重新思考你的整个策略。因为波动，你甚至无法为未来存钱。</li></ul><p>另外，作为一项技术，区块链本身并没有那么厉害。它的核心是一个去中心化的慢速只读数据库，它需要尽可能多的电力来运行，这些都没有多少现实生活中的有用的应用。是的，有人会说，有一个去中心化的零信任数据库会是一个优势，但我还没有看到一个使用区块链的系统，仅仅只是一个普通的数据库是不够的。</p><p>现实生活中的应用我只看到了审计跟踪，去中心化的部分是没有用的（只有通过哈希的区块链在那里有用，以避免篡改过去的记录）。但这种用例与区块链倡导者推广它的原因无关。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我看来，比特币是一种时尚，它的价值是两件事所赋予的：</p><ol><li>人们对一种资产有太多的信心，而这种资产并不是真正的资产，除了提供一个投机的机会外，没有任何用处；</li><li>还有就是人们的 FOMO，当朋友告诉他们应该买，或者大众媒体极少数月一次将它带到公众面前时，他们就会被一时的热度所吸引而买入。</li></ol><p>本文仅代表个人观点，不代表理财建议。我并不是在说“买”或“卖”。请自行思考。</p><p>Repost from: <a href="https://vladcalin.ro/blog/2021-02-07-about-blockchain" target="_blank" rel="noopener">https://vladcalin.ro/blog/2021-02-07-about-blockchain</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客的灵感来自于 Reddit 上的一个问题：你的投资中有多少是加密货币？&lt;/p&gt;
&lt;p&gt;好吧，我的回答是 0% 并且以后也依然是 0%.&lt;/p&gt;
&lt;p&gt;我看不到其价值所在，一堆人鼓吹它，然而这些人都是些伪君子：他们说他们使用加密货币是为了对抗目前被政府控制的 FIAT
      
    
    </summary>
    
    
      <category term="Blockchain" scheme="https://ismdeep.com/tags/Blockchain/"/>
    
      <category term="BitCoin" scheme="https://ismdeep.com/tags/BitCoin/"/>
    
  </entry>
  
  <entry>
    <title>Git 大文件存储</title>
    <link href="https://ismdeep.com/posts/2021-01-27-git-lfs.html"/>
    <id>https://ismdeep.com/posts/2021-01-27-git-lfs.html</id>
    <published>2021-01-27T10:09:22.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>Git Large File Storage (<code>git-lfs</code>) 是针对 Git 大文件存储的解决方案，开发者在 git 仓库中有时会有一些大型文件，比如：机器学习的数据集，音频文件，视频文件等等。</p><h1 id="1-安装-git-lfs-扩展"><a href="#1-安装-git-lfs-扩展" class="headerlink" title="1. 安装 git-lfs 扩展"></a>1. 安装 git-lfs 扩展</h1><p>macOS 下直接使用下面命令即可安装。</p><pre><code class="bash">brew install git-lfs</code></pre><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h1><p>在 git repo 中指明哪些文件需要使用 <code>git-lfs</code> 来进行大文件存储。</p><pre><code class="bash">git lfs track &quot;data/*&quot;</code></pre><p>以上命令表示 <code>data</code> 目录下所有文件都需要通过 <code>git-lfs</code> 来进行管理。</p><p>而且在 git repo 根目录会有一个 <code>.gitattributes</code> 文件，这个也是需要 <code>git add .gitattributes</code> 的。</p><p>注：上述命令中 <code>&quot;data/*&quot;</code> 需要加上引号，不然会被 bash shell 当成正则处理了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git Large File Storage (&lt;code&gt;git-lfs&lt;/code&gt;) 是针对 Git 大文件存储的解决方案，开发者在 git 仓库中有时会有一些大型文件，比如：机器学习的数据集，音频文件，视频文件等等。&lt;/p&gt;
&lt;h1 id=&quot;1-安装-git-lfs
      
    
    </summary>
    
    
      <category term="Development" scheme="https://ismdeep.com/tags/Development/"/>
    
      <category term="Git" scheme="https://ismdeep.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>软件推荐之 Ventoy</title>
    <link href="https://ismdeep.com/posts/2021-01-19-software-recommendation-ventoy.html"/>
    <id>https://ismdeep.com/posts/2021-01-19-software-recommendation-ventoy.html</id>
    <published>2021-01-19T09:37:35.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>Ventoy （ 官网地址：<a href="https://www.ventoy.net/" target="_blank" rel="noopener">https://www.ventoy.net/</a> ） 是一个制作可启动U盘的开源工具。有了Ventoy你就无需反复地格式化U盘，你只需要把 ISO/WIM/IMG/VHD(x)/EFI 等类型的文件拷贝到U盘里面就可以启动了，无需其他操作。<br>你可以一次性拷贝很多个不同类型的镜像文件，Ventoy 会在启动时显示一个菜单来供你进行选择 (参见 <a href="https://www.ventoy.net/cn/screenshot.html" target="_blank" rel="noopener">截图</a>)。<br>Ventoy 同时支持 x86 Legacy BIOS、IA32 UEFI、x86_64 UEFI 和 ARM64 UEFI 模式。支持大部分常见类型的操作系统 （Windows/WinPE/Linux/Unix/VMware/Xen …）<br>目前已经测试了各类超过 <strong>600+</strong> 个ISO文件(<a href="https://www.ventoy.net/cn/isolist.html" target="_blank" rel="noopener">列表</a>)。 支持 <a href="https://distrowatch.com/dwres.php?resource=popularity" target="_blank" rel="noopener">distrowatch.com</a> 网站上收录的 <strong>90%+</strong> 的操作系统(<a href="https://www.ventoy.net/cn/distrowatch.html" target="_blank" rel="noopener">列表</a>)。</p><p><strong>特点：</strong></p><ul><li>可以安装在 U盘/本地硬盘/SSD/NVMe/SD卡等设备上</li><li>直接从 ISO/WIM/IMG/VHD(x)/EFI 文件启动，无需解开</li><li>ISO/WIM/IMG/VHD(x)/EFI 文件在磁盘上无需连续</li><li>支持MBR和GPT分区格式</li><li>同时支持 x86 Legacy BIOS、IA32 UEFI、x86_64 UEFI、ARM64 UEFI</li><li>UEFI 模式支持安全启动 (Secure Boot) <a href="https://www.ventoy.net/cn/doc_secure.html" target="_blank" rel="noopener">说明</a></li><li>支持数据持久化 <a href="https://www.ventoy.net/cn/plugin_persistence.html" target="_blank" rel="noopener">说明</a></li><li>支持Windows系统的自动安装部署 <a href="https://www.ventoy.net/cn/plugin_autoinstall.html" target="_blank" rel="noopener">说明</a></li><li>支持 RHEL7/8/CentOS7/8/SUSE/Ubuntu Server/Debian 等Linux系统的自动安装部署 <a href="https://www.ventoy.net/cn/plugin_autoinstall.html" target="_blank" rel="noopener">说明</a></li><li>镜像分区支持 FAT32/exFAT/NTFS/UDF/XFS/Ext2(3)(4) 文件系统</li><li>支持超过4GB的ISO文件</li><li>保留ISO原始的启动菜单风格(Legacy &amp; UEFI)</li><li>支持大部分常见操作系统, 已测试600+ 个ISO文件</li><li>不仅仅是启动，而是完整的安装过程</li><li>菜单可以在列表模式和目录树模式之间实时、动态切换 <a href="https://www.ventoy.net/cn/doc_treeview.html" target="_blank" rel="noopener">说明</a></li><li>提出 “Ventoy Compatible” 概念</li><li>支持插件扩展</li><li>Linux vDisk(vhd/vdi/raw…) 启动解决方案</li><li>支持向运行环境中插入文件</li><li>动态替换ISO文件中的原始启动配置文件</li><li>高度可定制化的主题风格和菜单</li><li>启动过程中支持U盘设置写保护</li><li>不影响U盘日常普通使用</li><li>版本升级时数据不会丢失</li><li>无需跟随操作系统升级而升级Ventoy</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ventoy （ 官网地址：&lt;a href=&quot;https://www.ventoy.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ventoy.net/&lt;/a&gt; ） 是一个制作可启动U盘的开源工具。有了Ventoy你就无需
      
    
    </summary>
    
    
      <category term="Hacker" scheme="https://ismdeep.com/tags/Hacker/"/>
    
      <category term="Ubuntu" scheme="https://ismdeep.com/tags/Ubuntu/"/>
    
      <category term="Windows" scheme="https://ismdeep.com/tags/Windows/"/>
    
      <category term="Linux" scheme="https://ismdeep.com/tags/Linux/"/>
    
      <category term="Software" scheme="https://ismdeep.com/tags/Software/"/>
    
  </entry>
  
  <entry>
    <title>用 Markdown 来进行 LaTeX 写作</title>
    <link href="https://ismdeep.com/posts/2021-01-11-write-your-latex-document-with-markdown.html"/>
    <id>https://ismdeep.com/posts/2021-01-11-write-your-latex-document-with-markdown.html</id>
    <published>2021-01-11T11:17:15.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来 Markdown 和 LaTeX 都在吸引着我，各自有着各自的优缺点。Markdown 很简单，但是在论文排版、书籍排版等方面不够专业，只能用做简单的博客方面。LaTeX 有非常强大的排版系统，但是书写起来不够优雅，目前还没有见到有什么所见即所得的 LaTeX 编辑器。于是本文主要讲述目前笔者摸索出来的一套将 Markdown 与 LaTeX 结合起来进行文章混合写作的方法。</p><h1 id="1-什么是-Markdown-？"><a href="#1-什么是-Markdown-？" class="headerlink" title="1. 什么是 Markdown ？"></a>1. 什么是 Markdown ？</h1><p>Markdown 是一种轻量级的标记语言，允许人们使用简单易读的纯文本格式编写文档。编写出来的文档能够很轻松的转换成 HTML、Word、epub 等文档。得益于其简单易读的语法格式，Markdown 成为了程序员们编写文档的主要工具。不仅如此，越来越多的人开始使用 Markdown 来进行写作。Markdown 是一种文档标记语言，而针对 Markdown 的文档编辑器也非常多。主流使用的有：Typora、MWeb、MarkdownPad、Mou等。除了这些 Markdown 的文档编辑器，甚至有很多笔记软件也内置了 Markdown 语法支持，比如我们熟悉的印象笔记、有道云笔记、为知笔记、Notion等等。</p><h1 id="2-什么是-LaTeX-？"><a href="#2-什么是-LaTeX-？" class="headerlink" title="2. 什么是 $\LaTeX$ ？"></a>2. 什么是 $\LaTeX$ ？</h1><p>$\LaTeX$ 是一种基于 $\TeX$ 的排版系统。利用这种格式系统进行处理，即使使用者没有排版和程序设计的知识也可以充分发挥由 $\TeX$ 所提供的强大功能，使用者不需要一一亲自去设计或校对就能在几天甚至是几小时内生成很多具有书籍品质的印刷品。$\LaTeX$ 在生成复杂的表格和数学公式方面尤为突出。因此它非常适用于生成高质量的科技和数学、物理文档。</p><h1 id="3-文件组织方式"><a href="#3-文件组织方式" class="headerlink" title="3. 文件组织方式"></a>3. 文件组织方式</h1><p>Markdown 文件不宜过大，所以写的文件按章存放：<code>chapter01.md</code>, <code>chapter02.md</code> 等等。</p><p>如 <code>chapter01.md</code> ：</p><pre><code class="markdown"># 简介路径规划 \cite{Zafar2018} 在很多领域都具有广泛的应用，在高新科技领域的应用有：机器人的自主无碰撞行为；无人机的避障突防飞行等。</code></pre><p>通过 <code>pandoc -r markdown-auto_identifiers -w latex chapter01.md -o chapter01.tex</code> 可以生成对应的 <code>.tex</code> 文件。有了 <code>.tex</code> 文件，则可以在主文件中进行引用了。</p><p><code>main.tex</code> 如下：</p><pre><code class="tex">\documentclass[UTF8]{ctexart}\usepackage{url}\usepackage{hyperref}\title{路径规划算法研究}\author{L. Jiang}\date{\today}\begin{document}\maketitle\tableofcontents\input{chapter01}\bibliographystyle{IEEEtran}\bibliography{IEEEabrv,my}\end{document}</code></pre><p>而参考文献只需要新建一个 <code>my.bib</code> 文件，然后将文献管理器（如：Mendeley，EndNote等）导出的 BibTeX 格式的内容复制进去即可。而本人在使用 Mendeley 作为文献管理器时，最后直接将整个 Mendeley 所有文献全部导出或者将某个分类目录下的全部导出到 <code>my.bib</code> 文件即可，非常地银杏。</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/f0d7d378-231b-4d5f-a3a2-50b80f3b973d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210111%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20210111T062612Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=6acd0d3964858640df336f40743541177da0b69b9bdf8481f7079ca41085ef3b&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以来 Markdown 和 LaTeX 都在吸引着我，各自有着各自的优缺点。Markdown 很简单，但是在论文排版、书籍排版等方面不够专业，只能用做简单的博客方面。LaTeX 有非常强大的排版系统，但是书写起来不够优雅，目前还没有见到有什么所见即所得的 LaTeX 编
      
    
    </summary>
    
    
      <category term="LaTeX" scheme="https://ismdeep.com/tags/LaTeX/"/>
    
      <category term="Markdown" scheme="https://ismdeep.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://ismdeep.com/posts/2020-12-29-quick-sort.html"/>
    <id>https://ismdeep.com/posts/2020-12-29-quick-sort.html</id>
    <published>2020-12-29T19:52:31.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/zh-cn/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">快速排序</a>（英文：Quick Sort），也称为<strong>分区交换排序</strong>（Partition Exchange Sort），是一种排序算法。快速排序最早由 <strong>Tony Hoare</strong> 于 1961 年提出。其平均算法复杂度为 $O(n \log{n})$，然而最坏情况下算法复杂度为 $O(n^2)$，当然这种情况是非常极端的，大部分时候是不会发生这种事情的。</p><p>快速排序的主要排序思想在于：<strong>选出一个基准值，然后将所有比这个值小的值放置在左边，比这个值大的放在右边。接下来对左右两边的数值继续执行这个过程。</strong></p><p>比如：[5, 4, 2, 7, 3] 这组数字，假设我们选择基准为数字3，那么第一趟下来大致是这样的：[2, 3, 5, 4, 7]。那么在以 3 作为基准数字的一趟排序后，数组被分为了三个部分，[2], 3, 和 [5,4,7]. 3已经被确定下来位置了，那么接下来就继续使用以上操作分别对 [2] 和 [5,4,7] 进行排序即可。</p><p>在快速排序算法中有两个核心函数：<code>sort()</code> 和 <code>partition()</code></p><ul><li><code>sort()</code> 从上述能看出，快速排序是一个具有递归结构的算法，我们在设计的时候可以设计成 <code>void sort(int a[], size_t n);</code> 表示对数组 <code>a[]</code> 进行排序，那么为什么还要 <code>size_t n</code> 这个参数呢？我们都知道，在 C 语言中，传递的一个数组变量那只是传递了这个数组的首地址，所以还需要传递数组的大小。这里有同学可能会说，那分区之后如何对分区后的左右两个部分进行排序呢？并不是所有的分区都是从 <code>a[]</code> 的首地址开始的呀。技巧就是：我们只需要进行地址偏移就可以了。</li><li><code>partition()</code> 函数，对数组进行分区交换操作。设计的时候可以设计成 <code>size_t partition(int a[], size_t n);</code> 注意：这个函数是有返回值的。因为我们要告诉调用者分区最后基准值落在哪个位置，有了这个位置，就可以定位到分区之后被分成的左右两个部分，进而继续调用 <code>sort()</code> 函数进行排序了。</li></ul><h1 id="1-sort-函数"><a href="#1-sort-函数" class="headerlink" title="1. sort() 函数"></a>1. <code>sort()</code> 函数</h1><p> 实现上，首先判断一下 $n$ 的大小，没必要排序的情况下直接结束。然后接下来三个步骤：</p><ol><li>调用 <code>partition()</code> 函数进行分区，并获取基准值最后停下来的位置。</li><li>对分区后左部分进行排序。</li><li>对分区后右部分进行排序。</li></ol><p>这里需要注意的就是分区后左部分和右部分各自的起始地址和大小。</p><pre><code class="c">void sort(int a[], size_t n) {    if (n &lt;= 1) {        return;    }    size_t mid = partition(a, n);    sort(a, mid);    sort(a + mid + 1, n - mid - 1);}</code></pre><h1 id="2-partition-函数"><a href="#2-partition-函数" class="headerlink" title="2. partition() 函数"></a>2. <code>partition()</code> 函数</h1><p>分区函数，其实这才是快速排序最最核心的部分了。分区操作基准值选择需要分区的数组段最后一个值。首先将除去最后一个值的剩余部分分成左右两部分（左部分所有值小于基准值，右部分所有值大于基准值），然后将分区后右半部分的第一个与分区的数组段最后一个值（基准值）进行互换。这里其实有一个小操作，就是我们并不要着急去规定基准值最后的位置，毕竟咋也不知道具体多少个值是小于基准值的，多少个值是大于基准值的。而是我们直接将除了基准值剩下的分成两个部分，然后将右部分第一个与基准值换个地址就好了，反正这个值往右放并没有改变右边所有值都大于基准值的事实。</p><pre><code class="c">size_t partition(int a[], size_t n) {    if (n &lt;= 1) {        return 0;    }    size_t cursor_bottom = -1;    for (size_t i = 0; i &lt; n - 1; i++) {        if (a[i] &lt; a[n - 1]) {            cursor_bottom++;            swap(&amp;a[cursor_bottom], &amp;a[i]);        }    }    cursor_bottom++;    swap(&amp;a[cursor_bottom], &amp;a[n-1]);    return cursor_bottom;}</code></pre><h1 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3. 完整代码"></a>3. 完整代码</h1><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void print_arr(int a[], size_t n) {    for (size_t i = 0; i &lt; n; i++) {        printf(&quot;%2d &quot;, a[i]);    }    printf(&quot;\n&quot;);}void swap(int *a, int *b) {    int tmp;    tmp = *a;    *a = *b;    *b = tmp;}size_t partition(int a[], size_t n) {    if (n &lt;= 1) {        return 0;    }    size_t cursor_bottom = -1;    for (size_t i = 0; i &lt; n - 1; i++) {        if (a[i] &lt; a[n - 1]) {            cursor_bottom++;            swap(&amp;a[cursor_bottom], &amp;a[i]);        }    }    cursor_bottom++;    swap(&amp;a[cursor_bottom], &amp;a[n - 1]);    return cursor_bottom;}void sort(int a[], size_t n) {    if (n &lt;= 1) {        return;    }    size_t mid = partition(a, n);    sort(a, mid);    sort(a + mid + 1, n - mid - 1);}int main() {    int a[] = {4, 6, 3, 2, 7, 4, 2, 5, 6, 2};    print_arr(a, 10);    sort(a, 10);    print_arr(a, 10);    return EXIT_SUCCESS;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;快速排序&lt;/a&gt;（英文：Quick Sort），也称为&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://ismdeep.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>便携式 MySQL</title>
    <link href="https://ismdeep.com/posts/2020-12-15-portable-mysql.html"/>
    <id>https://ismdeep.com/posts/2020-12-15-portable-mysql.html</id>
    <published>2020-12-15T23:02:45.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>开发者日常就是需要面对各种各样的数据库，甚至有的开发者需要面对同样的产品不同版本的数据库，而且希望数据库软件不会影响到系统，如果是通过可执行文件进行安装的数据库软件，在安装多个版本的数据时候可能会出现一些版本冲突的情况，甚至是软件安装覆盖的问题。还有一个困扰就是我可能需要多个数据库实例，而且每个实例互不影响。那么本文的方法都是可以解决以上问题的。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>那么什么是 “便携式 MySQL” 呢？其实本文笔者写笔记的时候用的是 “Portable MySQL” 的标题。但还是更喜欢这个标题吧。便携式的意思就是软件不会与系统有太多的依赖。比如我在A机器上运行了一个 MySQL，但是我现在想把数据库迁移到另一台机器上，那么便携式在这件事情上的优点就是<strong>我们能够直接复制对应的数据目录到新的机器上就可以直接恢复运行了。</strong>而且还有一个优点就是<strong>便携式 MySQL 能够很方便的进行安装、卸载、迁移。</strong>这些优点都是现在软件开发中有关效率与安全性非常重要的。</p><h1 id="2-下载并安装"><a href="#2-下载并安装" class="headerlink" title="2. 下载并安装"></a>2. 下载并安装</h1><p>本文使用到的所有 MySQL 可执行文件都是可以在 MySQL 官网（<a href="https://dev.mysql.com/downloads/mysql/）进行下载的。" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/）进行下载的。</a></p><p>那么笔者下载的是 mysql-8.0.22-macos10.15-x86_64.tar.gz ，下载后解压并将其放至 <code>/Users/ismdeep/Apps/mysql-8.0.22-macos10.15-x86_64</code></p><h1 id="3-创建存放-MySQL-数据的文件夹"><a href="#3-创建存放-MySQL-数据的文件夹" class="headerlink" title="3. 创建存放 MySQL 数据的文件夹"></a>3. 创建存放 MySQL 数据的文件夹</h1><p>创建一个空文件夹 <code>/Users/ismdeep/Data/rawdata</code></p><p>该文件夹将用来保存 MySQL 数据库的数据，如果需要进行迁移则在数据库关闭之后复制这个文件夹即可。那如果需要启动新的数据库实例，则需要新建另一个数据库文件夹并按照以下步骤进行初始化数据库即可。</p><h1 id="4-初始化数据库"><a href="#4-初始化数据库" class="headerlink" title="4. 初始化数据库"></a>4. 初始化数据库</h1><p>首先对空白的文件夹进行数据库初始化。</p><pre><code class="bash">mysqld --initialize \       --user=mysql \       --basedir=/Users/ismdeep/Apps/mysql-8.0.22-macos10.15-x86_64 \       --datadir=/Users/ismdeep/Data/rawdata</code></pre><p>MySQL 8.0 默认使用的数据库密码是由 MySQL 自动随机生成的，这个密码会出现在以上命令执行的输出上。如果没有出现则会保存在数据文件夹中的后缀为 <code>.err</code> 的文件中。</p><h1 id="5-启动数据库"><a href="#5-启动数据库" class="headerlink" title="5. 启动数据库"></a>5. 启动数据库</h1><pre><code>mysqld --basedir=/Users/ismdeep/Apps/mysql-8.0.22-macos10.15-x86_64 \       --datadir=/Users/ismdeep/Data/rawdata</code></pre><p><code>mysqld</code> 命令常用参数说明：</p><ul><li><code>--daemonize</code> 后台守护进程模式</li><li><code>--bind-address=&lt;address&gt;</code> 绑定访问地址</li></ul><h1 id="6-修改-root-密码"><a href="#6-修改-root-密码" class="headerlink" title="6. 修改 root 密码"></a>6. 修改 root 密码</h1><p>在以上重新启动数据库之后首先要做的就是修改 root 密码。运行以下命令并输入上述所说随机初始化的密码。</p><pre><code>$ mysql -uroot -p -h127.0.0.1Enter password:</code></pre><p>接下来修改密码，这里为了方便叙述就使用 <code>123456</code> 作为密码，当然笔者非常不建议大家这样用，因为这样的密码太过简单。</p><pre><code>mysql&gt; alter user user() identified by &#39;123456&#39;;Query OK, 0 rows affected (0.00 sec)</code></pre><p>需要开启远程访问则增加以下命令（当然以上 <code>--bind-address</code> 参数也是需要设置的）：</p><pre><code>CREATE USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;;</code></pre><h1 id="7-关闭服务器命令"><a href="#7-关闭服务器命令" class="headerlink" title="7. 关闭服务器命令"></a>7. 关闭服务器命令</h1><pre><code>mysqladmin -uroot -p123456 shutdown</code></pre><h1 id="8-alias-小技巧"><a href="#8-alias-小技巧" class="headerlink" title="8. alias 小技巧"></a>8. alias 小技巧</h1><p>笔者觉得以上启动服务器和关闭服务器命令太麻烦了。所以会使用以下两个 alias 来简化。</p><pre><code>alias mysql-start=&quot;mysqld --daemonize --basedir=/Users/ismdeep/Apps/mysql-8.0.22-macos10.15-x86_64 --datadir=/Users/ismdeep/Data/rawdata&quot;alias mysql-stop=&quot;mysqladmin -uroot -pE0Lztvs238 shutdown&quot;</code></pre><p>这样启动服务器则使用 <code>mysql-start</code> ，关闭服务器则使用 <code>mysql-stop</code> 即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开发者日常就是需要面对各种各样的数据库，甚至有的开发者需要面对同样的产品不同版本的数据库，而且希望数据库软件不会影响到系统，如果是通过可执行文件进行安装的数据库软件，在安装多个版本的数据时候可能会出现一些版本冲突的情况，甚至是软件安装覆盖的问题。还有一个困扰就是我可能需要多
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://ismdeep.com/tags/MySQL/"/>
    
      <category term="Hacker" scheme="https://ismdeep.com/tags/Hacker/"/>
    
      <category term="Windows" scheme="https://ismdeep.com/tags/Windows/"/>
    
      <category term="Linux" scheme="https://ismdeep.com/tags/Linux/"/>
    
      <category term="Development" scheme="https://ismdeep.com/tags/Development/"/>
    
      <category term="macOS" scheme="https://ismdeep.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>重置 Downie 4 试用有效期</title>
    <link href="https://ismdeep.com/posts/2020-11-20-reset-downie-4-trial.html"/>
    <id>https://ismdeep.com/posts/2020-11-20-reset-downie-4-trial.html</id>
    <published>2020-11-20T10:27:21.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>Downie 4 是 macOS 上一款优秀的下载工具，不仅能够方便下载 YouTube 视频，还能够高效地下载 HTTP/HTTPS 链接资源。当然其实还支持非常多的视频网站下载视频。软件提供 14 天试用时间，试用期之内用户能够使用几乎所有正版购买的功能，这还是非常良心的，那么其实试用版对普通用户来说已经非常够用了。那么这个软件试用期 14 天过了之后，自然就需要用户考虑购买使用了。</p><p>本文所述重置 Downie 4 试用有效期的方法同样适用其他具有试用有效期的软件。</p><p>那么，试用有效期的原理就是：</p><ol><li>读取试用有效期文件</li><li><strong>IF</strong> 文件不存在 <strong>Do</strong></li><li>​    创建文件并写入当前时间</li><li><strong>END</strong> <strong>IF</strong></li><li></li><li><strong>IF</strong> 文件存在 <strong>AND</strong> 超出试用期 <strong>Do</strong></li><li>​    提示购买</li><li>​    <strong>EXIT</strong></li><li><strong>END</strong> <strong>IF</strong></li><li></li><li>显示剩余试用期时长</li></ol><p>针对这样的有效试用期判断方式的破解方式就很简单：找到试用有效期文件，将其删除即可。</p><p>至于怎么找呢，有很多方法，这里主要就是靠经验了。先找到软件存放数据的目录，macOS 下一般都在 <code>~/Library</code> 里面，然后可以通过目录查找的方式找软件的名称，当然还可以配合一些 App 数据清理工具查看 App 存放数据的目录或者是名称。这样能够大大降低搜索的范围。</p><p>至于 Downie 4 嘛，就用以下命令即可：</p><pre><code>rm -rfv &quot;/Users/ismdeep/Library/Containers/com.charliemonroe.Downie-4/Data/Library/Application Support/Downie 4&quot;</code></pre><p>当然，笔者是在 <code>~/.zshrc</code> 中设置了 alias 的</p><pre><code>alias reset-downie-trial=&#39;rm -rfv &quot;/Users/ismdeep/Library/Containers/com.charliemonroe.Downie-4/Data/Library/Application Support/Downie 4&quot;&#39;</code></pre><p>这样以后需要删除试用时间的话就执行 <code>reset-downie-trial</code> 即可。</p><p>好吧，扯了这么多，其实最后才是最重要的部分，就如之前看到一篇文章下的评论一样：一条***命令就行了，非要写这么长。这个嘛，我还是更想让各位明白个所以然啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Downie 4 是 macOS 上一款优秀的下载工具，不仅能够方便下载 YouTube 视频，还能够高效地下载 HTTP/HTTPS 链接资源。当然其实还支持非常多的视频网站下载视频。软件提供 14 天试用时间，试用期之内用户能够使用几乎所有正版购买的功能，这还是非常良心
      
    
    </summary>
    
    
      <category term="Hacker" scheme="https://ismdeep.com/tags/Hacker/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 构建漂亮的命令行程序</title>
    <link href="https://ismdeep.com/posts/2020-11-19-building-beautiful-command-line-interfaces-with-python.html"/>
    <id>https://ismdeep.com/posts/2020-11-19-building-beautiful-command-line-interfaces-with-python.html</id>
    <published>2020-11-19T21:22:31.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>在开始构建命令行应用程序之前，让我们来看一下什么是<strong>命令行</strong>。</p><p>自计算机程序创建以来，命令行程序就无处不在了，很多程序都是由命令构建的。命令行程序是一种通过命令行或者是 shell 进行操作的软件。</p><p>命令行界面（Command Line Interface，CLI）是一种可通过终端、shell 或控制台上键入命令来控制（而非使用鼠标）的用户界面。控制台是一种显示模式，其整个屏幕仅显示文本，没有图像和 GUI 控件。</p><p>根据维基百科：</p><blockquote><p>CLI 是 1960 年代中期与计算机终端上的大多数计算机系统进行交互的主要方式，并且在整个 1970 年代和 1980 年代继续在 OpenVMS 、 Unix 系统和包括 MS-DOS ，CP/M 和 Apple DOS 在内的个人计算机系统上使用。 该界面通常使用命令行 shell 实现，该命令行 shell 是一个接受命令作为文本输入并将命令转换为对应的操作系统功能。</p></blockquote><h1 id="1-为什么选择-Python-？"><a href="#1-为什么选择-Python-？" class="headerlink" title="1. 为什么选择 Python ？"></a>1. 为什么选择 Python ？</h1><p><img src="https://upload.ismdeep.com/images/2020/11/19/6bd5661b7670ac6dbf9d67677d3da7b0-a4764d.jpeg" alt="https://upload.ismdeep.com/images/2020/11/19/6bd5661b7670ac6dbf9d67677d3da7b0-a4764d.jpeg"></p><p>Python 经常因为其灵活性和与其他语言很好的结合使用的特性而被视作<em>胶水语言。</em>大部分 Python 代码都是用于脚本和命令行界面。</p><p>构建这些命令行界面和工具将变得非常强大，因为它们能够让你将想到的任何事情自动化执行成为可能。</p><p>我们处于一个漂亮且交互式界面的时代，所以 UI  (User Interactive，用户交互) 和 UX (User Experience ，用户体验) 至关重要。我们需要将这些内容添加到命令行中，以让人们能够实现它们。而这些已被 Heroku 等流行公司正式使用。</p><p>大量的 Python 库和模块可以帮助构建命令行应用程序，包括从参数解析和选项标记到完整的 CLI 框架。这些工具可以执行彩色输出，进度条，发送邮件等操作。</p><p>使用这些模块，你可以创建像 Heroku 以及 Node 中 Vue-init 和 NPM-init 这些漂亮的交互式命令行界面程序了。</p><p><img src="https://upload.ismdeep.com/images/2020/11/19/28b12eb6a3964bdcb5fb33a6e65d6490-54f1c0.png" alt="https://upload.ismdeep.com/images/2020/11/19/28b12eb6a3964bdcb5fb33a6e65d6490-54f1c0.png"></p><p>为了方便构建漂亮的 <code>vue init</code> 命令行程序，我建议使用 Python-inquirer ，这是 Inquirer.js 在 Python 的移植版本。</p><p>不幸的是，由于使用了 blessings 模块（一个引入了只有类 UNIX 系统才可以使用的 <code>_curses</code> 和 <code>fcntl</code> 模块的包），Python-inquirer 无法在 Windows 上运行。然而，有一些出色的开发人员能够将 <code>_curses</code> 移植到  Windows 上，但无法移植 <code>fcntl</code>. Windows 中的 <code>fctnl</code> 可替代品是 <code>win32api</code>.</p><p>但是，经过了在 Google 上大量的搜索之后，我碰到了一个 Python 模块，我对其进行全面修复，并将其称为 <a href="https://github.com/CITGuru/PyInquirer" target="_blank" rel="noopener">PyInquirer</a> ，它是 python-inquirer 的替代品。而它有一个很大的好处就是：它可以在包括 Windows 在内的所有操作系统平台上使用。<strong>赞！</strong></p><p><img src="https://upload.ismdeep.com/images/2020/11/19/930528e6684ff1da00bf4ce8e447dd53-92bcb5.jpg" alt="https://upload.ismdeep.com/images/2020/11/19/930528e6684ff1da00bf4ce8e447dd53-92bcb5.jpg"></p><h1 id="2-Python-命令行界面的基础知识"><a href="#2-Python-命令行界面的基础知识" class="headerlink" title="2. Python 命令行界面的基础知识"></a>2. Python 命令行界面的基础知识</h1><p>现在让我们来看看命令行界面，并在 Python 中创建一个。</p><p>命令行界面（CLI）通常以可执行文件的名称开头。你只需要在控制台中输入名称，这就是访问脚本的的主要入口点，例如 <code>pip</code>.</p><p>你需要根据脚本的开发方式将<strong>参数</strong>传递给脚本，它们可以是：</p><ol><li>参数<strong>:</strong> 这是传递给脚本的必需参数。如果不提供，程序就会出错。例如在：<code>pip install django</code> 这个命令中，<code>django</code> 就是命令的参数。</li><li>选项<strong>:</strong> 顾名思义，它是一个可选参数，通常是带有名称和值组成的对，例如：<code>pip install django --cache-dir ./my-cache-dir</code> 中 <code>-cache-dir</code> 是一个选项参数的名称，<code>./my-cache-dir</code> 则是值，这组成了一对，意义表示缓存目录指定为 <code>./my-cache-dir</code> 这个目录。</li><li>标志<strong>:</strong> 这是一个特殊的选项参数，它是用来告诉脚本启用或禁用某些行为，最常见的一种可能就是 <code>-help</code> 了。</li></ol><p>使用 Heroku Toolbelt 等复杂的命令行程序，其实是将访问的所有命令全部归入到主入口点了。它们通常被视为<strong>命令</strong>或者<strong>子命令</strong>。</p><p>现在，让我们看以下如何使用不同的 Python 包构建智能且美观的命令行程序。</p><h1 id="3-Argparse"><a href="#3-Argparse" class="headerlink" title="3. Argparse"></a>3. <strong>Argparse</strong></h1><p><strong>Argparse</strong> 是 Python 中用于构建命令行程序自带的模块。它提供了构建简单的命令行程序的所需的所有功能。</p><pre><code class="python">import argparseparser = argparse.ArgumentParser(description=&#39;Add some integers.&#39;)parser.add_argument(&#39;integers&#39;, metavar=&#39;N&#39;, type=int, nargs=&#39;+&#39;,                    help=&#39;interger list&#39;)parser.add_argument(&#39;--sum&#39;, action=&#39;store_const&#39;,                    const=sum, default=max,                    help=&#39;sum the integers (default: find the max)&#39;)args = parser.parse_args()print(args.sum(args.integers))</code></pre><p>这是一个简单的加法操作。<code>argparse.ArgumentParser</code> 让你能够添加程序描述到其中，而 <code>parser.add_argument</code> 让你添加一个命令。<code>parser.parse_args()</code> 则会返回一组参数，它们通常以 名称-值 对的形式出现。</p><p>例如：你可以通过 <code>args.integers</code> 访问 <code>integers</code> 的参数值。在上述脚本中，<code>-sum</code> 是一个可选参数， <code>N</code> 是位置参数。</p><h1 id="4-Click"><a href="#4-Click" class="headerlink" title="4. Click"></a>4. Click</h1><p>与 Argparse 相比，使用 <a href="https://github.com/pallets/click" target="_blank" rel="noopener">Click</a> 能够更简单的创建命令行程序。argparse 能做的，Click 同样能做。但是使用了稍微不一样的方法。它使用了 <em>decorators</em> 的概念，这使命令成为可以使用装饰器包装的函数。</p><pre><code class="python"># cli.pyimport click@click.command()def main():    click.echo(&quot;This is a CLI built with Click ✨&quot;)if __name__ == &quot;__main__&quot;:    main()</code></pre><p>你可以按下面的方式添加参数和选项：</p><pre><code class="python"># cli.pyimport click@click.command()@click.argument(&#39;name&#39;)@click.option(&#39;--greeting&#39;, &#39;-g&#39;)def main(name, greeting):    click.echo(&quot;{}, {}&quot;.format(greeting, name))if __name__ == &quot;__main__&quot;:    main()</code></pre><p>运行上述脚本，则应有：</p><pre><code>$ python cli.py --greeting &lt;greeting&gt; OyetokeHey, Oyetoke</code></pre><p>将以上所有的整合在一起，我能够构建一个简单的命令行（CLI）程序来查询 Google Books 中的图书。</p><pre><code class="python">import clickimport requests__author__ = &quot;Oyetoke Toby&quot;@click.group()def main():    &quot;&quot;&quot;    Simple CLI for querying books on Google Books by Oyetoke Toby    &quot;&quot;&quot;    pass@main.command()@click.argument(&#39;query&#39;)def search(query):    &quot;&quot;&quot;This search and return results corresponding to the given query from Google Books&quot;&quot;&quot;    url_format = &#39;&lt;https://www.googleapis.com/books/v1/volumes&gt;&#39;    query = &quot;+&quot;.join(query.split())    query_params = {        &#39;q&#39;: query    }    response = requests.get(url_format, params=query_params)    click.echo(response.json()[&#39;items&#39;]) @main.command()@click.argument(&#39;id&#39;)def get(id):    &quot;&quot;&quot;This return a particular book from the given id on Google Books&quot;&quot;&quot;    url_format = &#39;&lt;https://www.googleapis.com/books/v1/volumes/{}&gt;&#39;    click.echo(id)    response = requests.get(url_format.format(id))    click.echo(response.json())if __name__ == &quot;__main__&quot;:    main()</code></pre><p>更多有关信息，您可以从<a href="http://click.pocoo.org/" target="_blank" rel="noopener">官方文档</a>上深入了解 Click.</p><h1 id="5-Docopt"><a href="#5-Docopt" class="headerlink" title="5. Docopt"></a>5. Docopt</h1><p><a href="http://docopt.org/" target="_blank" rel="noopener">Docopt</a> 是一个轻量级的 Python 软件包，可以通过解析 POSIC-样式 或 Markdown 使用说明轻松地创建命令行界面。Docopt 使用多年来用于格式化帮助信息和手册页来描述命令行界面的约定。 <code>*docopt**</code> 中的界面描述就是这样的帮助信息，但是形式化。</p><p>Docopt 非常关心文件顶部格式化所需的文档字符串方式。在工具名称的下一行开始，文档第一部分顶部必需是 “Usage”，并且应列出你期望命令被调用的方式。</p><p>文档的第二部分开始必需是 “Options” ，这应该提供有关在 “Usage” 中标识的选项和参数的更多信息。文档字符串的内容将程序帮助文档的内容。</p><pre><code class="python">&quot;&quot;&quot;HELLO CLIUsage:    hello.py    hello.py &lt;name&gt;    hello.py -h|--help    hello.py -v|--versionOptions:    &lt;name&gt;  Optional name argument.    -h --help  Show this screen.    -v --version  Show version.&quot;&quot;&quot;from docopt import docoptdef say_hello(name):    return(&quot;Hello {}!&quot;.format(name))if __name__ == &#39;__main__&#39;:    arguments = docopt(__doc__, version=&#39;DEMO 1.0&#39;)    if arguments[&#39;&lt;name&gt;&#39;]:        print(say_hello(arguments[&#39;&lt;name&gt;&#39;]))    else:        print(arguments)</code></pre><h1 id="6-PyInquirer"><a href="#6-PyInquirer" class="headerlink" title="6. PyInquirer"></a>6. PyInquirer</h1><p><a href="https://github.com/CITGuru/PyInquirer" target="_blank" rel="noopener">PyInquirer</a> 是一个用于交互式命令行用户界面的模块。我们在上面看到的程序包并没有实现我们想要的 “漂亮界面” 的目标。因此，让我们来看以下如何使用 PyInquirer.</p><p>像 Inquirer.js 一样，PyInquirer 分为两个简单的步骤：</p><ol><li>您定义<strong>问题列表</strong>并将其传递给<strong>命令行</strong>。</li><li>命令行返回<strong>答案列表</strong>。</li></ol><pre><code class="python">from __future__ import print_function, unicode_literalsfrom PyInquirer import promptfrom pprint import pprintquestions = [    {        &#39;type&#39;: &#39;input&#39;,        &#39;name&#39;: &#39;first_name&#39;,        &#39;message&#39;: &#39;What\&#39;s your first name&#39;,     }]answers = prompt(questions)pprint(answers)</code></pre><p>一个互动的例子</p><pre><code class="python">from __future__ import print_function, unicode_literalsfrom PyInquirer import style_from_dict, Token, prompt, Separatorfrom pprint import pprintstyle = style_from_dict({    Token.Separator: &#39;#cc5454&#39;,    Token.QuestionMark: &#39;#673ab7 bold&#39;,    Token.Selected: &#39;#cc5454&#39;,  # default    Token.Pointer: &#39;#673ab7 bold&#39;,    Token.Instruction: &#39;&#39;,  # default    Token.Answer: &#39;#f44336 bold&#39;,    Token.Question: &#39;&#39;,})questions = [    {        &#39;type&#39;: &#39;checkbox&#39;,        &#39;message&#39;: &#39;Select toppings&#39;,        &#39;name&#39;: &#39;toppings&#39;,        &#39;choices&#39;: [            Separator(&#39;= The Meats =&#39;),            {                &#39;name&#39;: &#39;Ham&#39;            },            {                &#39;name&#39;: &#39;Ground Meat&#39;            },            {                &#39;name&#39;: &#39;Bacon&#39;            },            Separator(&#39;= The Cheeses =&#39;),            {                &#39;name&#39;: &#39;Mozzarella&#39;,                &#39;checked&#39;: True            },            {                &#39;name&#39;: &#39;Cheddar&#39;            },            {                &#39;name&#39;: &#39;Parmesan&#39;            },            Separator(&#39;= The usual =&#39;),            {                &#39;name&#39;: &#39;Mushroom&#39;            },            {                &#39;name&#39;: &#39;Tomato&#39;            },            {                &#39;name&#39;: &#39;Pepperoni&#39;            },            Separator(&#39;= The extras =&#39;),            {                &#39;name&#39;: &#39;Pineapple&#39;            },            {                &#39;name&#39;: &#39;Olives&#39;,                &#39;disabled&#39;: &#39;out of stock&#39;            },            {                &#39;name&#39;: &#39;Extra cheese&#39;            }        ],        &#39;validate&#39;: lambda answer: &#39;You must choose at least one topping.&#39; \\            if len(answer) == 0 else True    }]answers = prompt(questions, style=style)pprint(answers)</code></pre><p>结果：</p><p><img src="https://upload.ismdeep.com/images/2020/11/19/3dda204e0e32445743d5e8b0aa11d7a6-21b129.png" alt="https://upload.ismdeep.com/images/2020/11/19/3dda204e0e32445743d5e8b0aa11d7a6-21b129.png"></p><p>让我们来看看脚本的部分内容：</p><pre><code class="python">style = style_from_dict({Token.Separator: &#39;#cc5454&#39;,Token.QuestionMark: &#39;#673ab7 bold&#39;,Token.Selected: &#39;#cc5454&#39;,  # defaultToken.Pointer: &#39;#673ab7 bold&#39;,Token.Instruction: &#39;&#39;,  # defaultToken.Answer: &#39;#f44336 bold&#39;,Token.Question: &#39;&#39;,})</code></pre><p><code>style_from_dict</code> 被用来定义让界面自定义样式。 <code>Token</code> 就像一个组件，它下面有其他的组件。</p><p>我们在前面的示例中看到了 <code>questions</code> 列表。并将其传递到<code>prompt</code> 中进行处理。</p><p>你可以按照下面的示例来创建一个交互式命令行程序：</p><pre><code class="python"># -*- coding: utf-8 -*-from __future__ import print_function, unicode_literalsimport regexfrom pprint import pprintfrom PyInquirer import style_from_dict, Token, promptfrom PyInquirer import Validator, ValidationErrorstyle = style_from_dict({    Token.QuestionMark: &#39;#E91E63 bold&#39;,    Token.Selected: &#39;#673AB7 bold&#39;,    Token.Instruction: &#39;&#39;,  # default    Token.Answer: &#39;#2196f3 bold&#39;,    Token.Question: &#39;&#39;,})class PhoneNumberValidator(Validator):    def validate(self, document):        ok = regex.match(&#39;^([01]{1})?[-.\\s]?\\(?(\\d{3})\\)?[-.\\s]?(\\d{3})[-.\\s]?(\\d{4})\\s?((?:#|ext\\.?\\s?|x\\.?\\s?){1}(?:\\d+)?)?$&#39;, document.text)        if not ok:            raise ValidationError(                message=&#39;Please enter a valid phone number&#39;,                cursor_position=len(document.text))  # Move cursor to endclass NumberValidator(Validator):    def validate(self, document):        try:            int(document.text)        except ValueError:            raise ValidationError(                message=&#39;Please enter a number&#39;,                cursor_position=len(document.text))  # Move cursor to endprint(&#39;Hi, welcome to Python Pizza&#39;)questions = [    {        &#39;type&#39;: &#39;confirm&#39;,        &#39;name&#39;: &#39;toBeDelivered&#39;,        &#39;message&#39;: &#39;Is this for delivery?&#39;,        &#39;default&#39;: False    },    {        &#39;type&#39;: &#39;input&#39;,        &#39;name&#39;: &#39;phone&#39;,        &#39;message&#39;: &#39;What\&#39;s your phone number?&#39;,        &#39;validate&#39;: PhoneNumberValidator    },    {        &#39;type&#39;: &#39;list&#39;,        &#39;name&#39;: &#39;size&#39;,        &#39;message&#39;: &#39;What size do you need?&#39;,        &#39;choices&#39;: [&#39;Large&#39;, &#39;Medium&#39;, &#39;Small&#39;],        &#39;filter&#39;: lambda val: val.lower()    },    {        &#39;type&#39;: &#39;input&#39;,        &#39;name&#39;: &#39;quantity&#39;,        &#39;message&#39;: &#39;How many do you need?&#39;,        &#39;validate&#39;: NumberValidator,        &#39;filter&#39;: lambda val: int(val)    },    {        &#39;type&#39;: &#39;expand&#39;,        &#39;name&#39;: &#39;toppings&#39;,        &#39;message&#39;: &#39;What about the toppings?&#39;,        &#39;choices&#39;: [            {                &#39;key&#39;: &#39;p&#39;,                &#39;name&#39;: &#39;Pepperoni and cheese&#39;,                &#39;value&#39;: &#39;PepperoniCheese&#39;            },            {                &#39;key&#39;: &#39;a&#39;,                &#39;name&#39;: &#39;All dressed&#39;,                &#39;value&#39;: &#39;alldressed&#39;            },            {                &#39;key&#39;: &#39;w&#39;,                &#39;name&#39;: &#39;Hawaiian&#39;,                &#39;value&#39;: &#39;hawaiian&#39;            }        ]    },    {        &#39;type&#39;: &#39;rawlist&#39;,        &#39;name&#39;: &#39;beverage&#39;,        &#39;message&#39;: &#39;You also get a free 2L beverage&#39;,        &#39;choices&#39;: [&#39;Pepsi&#39;, &#39;7up&#39;, &#39;Coke&#39;]    },    {        &#39;type&#39;: &#39;input&#39;,        &#39;name&#39;: &#39;comments&#39;,        &#39;message&#39;: &#39;Any comments on your purchase experience?&#39;,        &#39;default&#39;: &#39;Nope, all good!&#39;    },    {        &#39;type&#39;: &#39;list&#39;,        &#39;name&#39;: &#39;prize&#39;,        &#39;message&#39;: &#39;For leaving a comment, you get a freebie&#39;,        &#39;choices&#39;: [&#39;cake&#39;, &#39;fries&#39;],        &#39;when&#39;: lambda answers: answers[&#39;comments&#39;] != &#39;Nope, all good!&#39;    }]answers = prompt(questions, style=style)print(&#39;Order receipt:&#39;)pprint(answers)</code></pre><p>结果：</p><p><img src="https://upload.ismdeep.com/images/2020/11/19/bba36b8ea3673d380414708274d217a8-2bd40f.png" alt="https://upload.ismdeep.com/images/2020/11/19/bba36b8ea3673d380414708274d217a8-2bd40f.png"></p><h1 id="7-PyFiglet"><a href="#7-PyFiglet" class="headerlink" title="7. PyFiglet"></a>7. PyFiglet</h1><p><a href="https://github.com/pwaller/pyfiglet" target="_blank" rel="noopener">Pyfiglet</a>  是一个用于将字符串转换为带有艺术字体的 ASCII 文本的 Python 模块。Pyfiglet 是 FIGlet (<a href="http://www.figlet.org/" target="_blank" rel="noopener">http://www.figlet.org/</a>) 在纯 Python 中的完整移植。</p><pre><code class="python">from pyfiglet import Figletf = Figlet(font=&#39;slant&#39;)print f.renderText(&#39;text to render&#39;)</code></pre><p>运行结果：</p><p><img src="https://upload.ismdeep.com/images/2020/11/19/bfd7023cef9b4d8f735c6239a18508d3-9afe30.png" alt="https://upload.ismdeep.com/images/2020/11/19/bfd7023cef9b4d8f735c6239a18508d3-9afe30.png"></p><h1 id="8-Clint"><a href="#8-Clint" class="headerlink" title="8. Clint"></a>8. Clint</h1><p><a href="https://pypi.org/project/clint/" target="_blank" rel="noopener">Clint</a> 包含了创建命令行程序所需的一切。它支持颜色，超强的可嵌套缩紧上下文管理器，支持自定义邮件样式的引号，超强列打印以及可选的自动扩展列，等等。</p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-from __future__ import print_functionimport sysimport ossys.path.insert(0, os.path.abspath(&#39;..&#39;))from clint.arguments import Argsfrom clint.textui import puts, colored, indentargs = Args()with indent(4, quote=&#39;&gt;&gt;&gt;&#39;):    puts(colored.blue(&#39;Aruments passed in: &#39;) + str(args.all))    puts(colored.blue(&#39;Flags detected: &#39;) + str(args.flags))    puts(colored.blue(&#39;Files detected: &#39;) + str(args.files))    puts(colored.blue(&#39;NOT Files detected: &#39;) + str(args.not_files))    puts(colored.blue(&#39;Grouped Arguments: &#39;) + str(dict(args.grouped)))print()</code></pre><p><img src="https://upload.ismdeep.com/images/2020/11/19/5f2a366af561dc6b9ea03a2c186b197f-0857fd.png" alt="https://upload.ismdeep.com/images/2020/11/19/5f2a366af561dc6b9ea03a2c186b197f-0857fd.png"></p><p>酷吧？我知道。</p><h1 id="9-其他-Python-CLI-工具"><a href="#9-其他-Python-CLI-工具" class="headerlink" title="9. 其他 Python CLI 工具"></a>9. 其他 Python CLI 工具</h1><p><strong><a href="http://builtoncement.com/" target="_blank" rel="noopener">Cement</a>:</strong> 它是完整的命令行界面框架。Cement 提供了轻量且功能齐全的基础，可以构建从单个文件脚本到复杂且设计精巧的应用程序。</p><p><strong><a href="https://docs.openstack.org/cliff/latest/" target="_blank" rel="noopener">Cliff</a>:</strong> Cliff 是用于构建命令行程序的框架。它使用 setuptools 入口点提供子命令，输出格式化程序和其他扩展。</p><p><strong><a href="https://pypi.python.org/pypi/plac" target="_blank" rel="noopener">Plac</a>:</strong> Plac 是 Python 标准库 argparse 的简单封装。该库通过声明性接口隐藏了大多数复杂的东西：推断参数解析器，而不是强制性地写下来。</p><h1 id="10-EmailCLI"><a href="#10-EmailCLI" class="headerlink" title="10. EmailCLI"></a>10. EmailCLI</h1><p>将所有内容加在一起，我编写了一个简单的命令行程序，用于通过 SendGrid 发送邮件。因此，要使用以下脚本，请从 <a href="https://sendgrid.com/" target="_blank" rel="noopener">SendGrid</a> 获取你的 API 密钥。</p><h2 id="10-1-安装"><a href="#10-1-安装" class="headerlink" title="10.1 安装"></a>10.1 安装</h2><pre><code>pip install sendgrid click PyInquirer pyfiglet pyconfigstore colorama termcolor six</code></pre><pre><code class="python">import osimport reimport clickimport sendgridimport sixfrom pyconfigstore import ConfigStorefrom PyInquirer import (Token, ValidationError, Validator, print_json, prompt,                        style_from_dict)from sendgrid.helpers.mail import *from pyfiglet import figlet_formattry:    import colorama    colorama.init()except ImportError:    colorama = Nonetry:    from termcolor import coloredexcept ImportError:    colored = Noneconf = ConfigStore(&quot;EmailCLI&quot;)style = style_from_dict({    Token.QuestionMark: &#39;#fac731 bold&#39;,    Token.Answer: &#39;#4688f1 bold&#39;,    Token.Instruction: &#39;&#39;,  # default    Token.Separator: &#39;#cc5454&#39;,    Token.Selected: &#39;#0abf5b&#39;,  # default    Token.Pointer: &#39;#673ab7 bold&#39;,    Token.Question: &#39;&#39;,})def getDefaultEmail(answer):    try:        from_email = conf.get(&quot;from_email&quot;)    except KeyError, Exception:        from_email = u&quot;&quot;    return from_emaildef getContentType(answer, conttype):    return answer.get(&quot;content_type&quot;).lower() == conttype.lower()def sendMail(mailinfo):    sg = sendgrid.SendGridAPIClient(api_key=conf.get(&quot;api_key&quot;))    from_email = Email(mailinfo.get(&quot;from_email&quot;))    to_email = Email(mailinfo.get(&quot;to_email&quot;))    subject = mailinfo.get(&quot;subject&quot;).title()    content_type = &quot;text/plain&quot; if mailinfo.get(&quot;content_type&quot;) == &quot;text&quot; else &quot;text/html&quot;    content = Content(content_type, mailinfo.get(&quot;content&quot;))    mail = Mail(from_email, subject, to_email, content)    response = sg.client.mail.send.post(request_body=mail.get())    return responsedef log(string, color, font=&quot;slant&quot;, figlet=False):    if colored:        if not figlet:            six.print_(colored(string, color))        else:            six.print_(colored(figlet_format(                string, font=font), color))    else:        six.print_(string)class EmailValidator(Validator):    pattern = r&quot;\\&quot;?([-a-zA-Z0-9.`?{}]+@\\w+\\.\\w+)\\&quot;?&quot;    def validate(self, email):        if len(email.text):            if re.match(self.pattern, email.text):                return True            else:                raise ValidationError(                    message=&quot;Invalid email&quot;,                    cursor_position=len(email.text))        else:            raise ValidationError(                message=&quot;You can&#39;t leave this blank&quot;,                cursor_position=len(email.text))class EmptyValidator(Validator):    def validate(self, value):        if len(value.text):            return True        else:            raise ValidationError(                message=&quot;You can&#39;t leave this blank&quot;,                cursor_position=len(value.text))class FilePathValidator(Validator):    def validate(self, value):        if len(value.text):            if os.path.isfile(value.text):                return True            else:                raise ValidationError(                    message=&quot;File not found&quot;,                    cursor_position=len(value.text))        else:            raise ValidationError(                message=&quot;You can&#39;t leave this blank&quot;,                cursor_position=len(value.text))class APIKEYValidator(Validator):    def validate(self, value):        if len(value.text):            sg = sendgrid.SendGridAPIClient(                api_key=value.text)            try:                response = sg.client.api_keys._(value.text).get()                if response.status_code == 200:                    return True            except:                raise ValidationError(                    message=&quot;There is an error with the API Key!&quot;,                    cursor_position=len(value.text))        else:            raise ValidationError(                message=&quot;You can&#39;t leave this blank&quot;,                cursor_position=len(value.text))def askAPIKEY():    questions = [        {            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;api_key&#39;,            &#39;message&#39;: &#39;Enter SendGrid API Key (Only needed to provide once)&#39;,            &#39;validate&#39;: APIKEYValidator,        },    ]    answers = prompt(questions, style=style)    return answersdef askEmailInformation():    questions = [        {            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;from_email&#39;,            &#39;message&#39;: &#39;From Email&#39;,            &#39;default&#39;: getDefaultEmail,            &#39;validate&#39;: EmailValidator        },        {            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;to_email&#39;,            &#39;message&#39;: &#39;To Email&#39;,            &#39;validate&#39;: EmailValidator        },        {            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;subject&#39;,            &#39;message&#39;: &#39;Subject&#39;,            &#39;validate&#39;: EmptyValidator        },        {            &#39;type&#39;: &#39;list&#39;,            &#39;name&#39;: &#39;content_type&#39;,            &#39;message&#39;: &#39;Content Type:&#39;,            &#39;choices&#39;: [&#39;Text&#39;, &#39;HTML&#39;],            &#39;filter&#39;: lambda val: val.lower()        },        {            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;content&#39;,            &#39;message&#39;: &#39;Enter plain text:&#39;,            &#39;when&#39;: lambda answers: getContentType(answers, &quot;text&quot;),            &#39;validate&#39;: EmptyValidator        },        {            &#39;type&#39;: &#39;confirm&#39;,            &#39;name&#39;: &#39;confirm_content&#39;,            &#39;message&#39;: &#39;Do you want to send an html file&#39;,            &#39;when&#39;: lambda answers: getContentType(answers, &quot;html&quot;)        },        {            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;content&#39;,            &#39;message&#39;: &#39;Enter html:&#39;,            &#39;when&#39;: lambda answers: not answers.get(&quot;confirm_content&quot;, True),            &#39;validate&#39;: EmptyValidator        },        {            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;content&#39;,            &#39;message&#39;: &#39;Enter html path:&#39;,            &#39;validate&#39;: FilePathValidator,            &#39;filter&#39;: lambda val: open(val).read(),            &#39;when&#39;: lambda answers: answers.get(&quot;confirm_content&quot;, False)        },        {            &#39;type&#39;: &#39;confirm&#39;,            &#39;name&#39;: &#39;send&#39;,            &#39;message&#39;: &#39;Do you want to send now&#39;        }    ]    answers = prompt(questions, style=style)    return answers@click.command()def main():    &quot;&quot;&quot;    Simple CLI for sending emails using SendGrid    &quot;&quot;&quot;    log(&quot;Email CLI&quot;, color=&quot;blue&quot;, figlet=True)    log(&quot;Welcome to Email CLI&quot;, &quot;green&quot;)    try:        api_key = conf.get(&quot;api_key&quot;)    except KeyError:        api_key = askAPIKEY()        conf.set(api_key)    mailinfo = askEmailInformation()    if mailinfo.get(&quot;send&quot;, False):        conf.set(&quot;from_email&quot;, mailinfo.get(&quot;from_email&quot;))        try:            response = sendMail(mailinfo)        except Exception as e:            raise Exception(&quot;An error occured: %s&quot; % (e))        if response.status_code == 202:            log(&quot;Mail sent successfully&quot;, &quot;blue&quot;)        else:            log(&quot;An error while trying to send&quot;, &quot;red&quot;)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><img src="https://upload.ismdeep.com/images/2020/11/19/cf5a82fe55a7ff783b88f86c236349fc-ca9e34.png" alt="https://upload.ismdeep.com/images/2020/11/19/cf5a82fe55a7ff783b88f86c236349fc-ca9e34.png"></p><p>如此而已。</p><p>可以看看这篇文章 <a href="https://www.davidfischer.name/2017/01/python-command-line-apps/" target="_blank" rel="noopener">https://www.davidfischer.name/2017/01/python-command-line-apps/</a></p><p>翻译自：<a href="https://codeburst.io/building-beautiful-command-line-interfaces-with-python-26c7e1bb54df" target="_blank" rel="noopener">https://codeburst.io/building-beautiful-command-line-interfaces-with-python-26c7e1bb54df</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开始构建命令行应用程序之前，让我们来看一下什么是&lt;strong&gt;命令行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;自计算机程序创建以来，命令行程序就无处不在了，很多程序都是由命令构建的。命令行程序是一种通过命令行或者是 shell 进行操作的软件。&lt;/p&gt;
&lt;p&gt;命令行界面（Co
      
    
    </summary>
    
    
      <category term="Python" scheme="https://ismdeep.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2020年蓝桥杯全国总决赛——皮亚诺曲线</title>
    <link href="https://ismdeep.com/posts/2020-11-17-hilbert-curve.html"/>
    <id>https://ismdeep.com/posts/2020-11-17-hilbert-curve.html</id>
    <published>2020-11-17T18:42:55.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>皮亚诺曲线（英语：Peano Curve，也称：希尔伯特曲线，Hilbert Curve）是一条能够填满正方形的曲线。在传统概念中，曲线的数维是1维，正方形是2维的。详细介绍见：<a href="https://zh.wikipedia.org/zh-cn/%E7%9A%AE%E4%BA%9A%E8%AF%BA%E6%9B%B2%E7%BA%BF" target="_blank" rel="noopener">维基百科：皮亚诺曲线</a></p><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>皮亚诺曲线是一条平面内的曲线，下图给出了皮亚诺曲线的 1 阶情形，它是从左下角出发，经过一个 3 × 3 的方格中的每一个格子，最终到达右上角的一条曲线。</p><p><img src="https://upload.ismdeep.com/images/2020/11/17/3f282b6c64756110753712d0f3cf5e81-f86fc3.png" alt="img"></p><p>下图给出了皮亚诺曲线的 2 阶情形，它是经过一个 32 × 32 的方格中的每一个格子的一条曲线。它是将 1 阶曲线的每个方格由 1 阶曲线替换而成。</p><p><img src="https://upload.ismdeep.com/images/2020/11/17/e4756f6a8d6f793ea06b2d3e5fd364f1-028733.png" alt="img"></p><p>下图给出了皮亚诺曲线的 3 阶情形，它是经过一个 33 × 33 的方格中的每一个格子的一条曲线。它是将 2 阶曲线的每个方格由 1 阶曲线替换而成。</p><p><img src="https://upload.ismdeep.com/images/2020/11/17/9f4c990545830ede819aca69522f9cf3-d44c33.png" alt="img"></p><p>皮亚诺曲线总是从左下角开始出发，最终到达右上角。</p><p><strong>问题：求给定阶数的皮亚诺曲线中任意两个相邻点数值差之和。</strong>比如：</p><p>$1$ 阶皮亚诺曲线所有相邻点差值和为 $24$.</p><p>$2$ 阶皮亚诺曲线所有相邻点差值和为 $816$.</p><p>比赛中题目最后要求的是 $n = 14$ ，即求 $14$ 阶皮亚诺曲线中任意两个相邻点数值差的和。</p><h1 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h1><p>首先，如果通过暴力打表，然后将所有相邻点差值的和累加起来，当然是不现实的。想想空间复杂度和时间复杂度就明白了。这里我们能够很容易得到空间复杂度是 $O((3^n)^2)$，估算一下当 $n = 14$ 时，内存至少需要 $170445$ GB.</p><pre><code>&gt;&gt;&gt; (3 ** 14) ** 2 * 8.0 / 1024.0 / 1024.0 / 1024.0170445.38598478585</code></pre><p>别做梦了，暴力杯并不是所有题都是可以暴力的。</p><p>那这样的题目应该怎么做呢？虽然 $n = 14$ 我们做不到，但是 $n$ 比较小的时候还是能够处理的嘛。比如：$n = 1$， $n = 2$ 这样的。先写一个模拟出来，再找找规律看看。（<em>其实这样的一个解题思路基本上是么得问题的。</em>）</p><p>对于这个东西该怎么模拟呢，请先看下面两张图，分别为 $1$ 阶皮亚诺曲线和 $2$ 阶皮亚诺曲线大致走向示意图。</p><p><img src="https://upload.ismdeep.com/images/2020/11/17/e2568c2d390c3517808ca11a71ff942d-057a40.jpg" alt="MnTOZP18TPSHNIm+aFmeRg_thumb_6b1" style="zoom: 25%;"></p><p><img src="https://upload.ismdeep.com/images/2020/11/17/96a33f5d08d8b33cc722ed9696810538-411135.jpg" alt="yuQ3JrzlSnSezgL+XhF%Ag_thumb_6ae" style="zoom: 25%;"></p><p>我们发现在所有的皮亚诺曲线中，大致走向只有四个方向：↗️、↖️、↘️、↙️，依次编号为1，2，3，4.</p><ol><li>↗️</li><li>↖️</li><li>↘️</li><li>↙️</li></ol><p>而皮亚诺曲线升阶（比如1阶变到2阶）过程，就是对基阶皮亚诺曲线进行扩展操作。比如我们看 $1$ 阶升阶为 $2$ 阶就是对↗️走向扩展为 9 个走向↗️↖️↗️ ↘️↙️↘️ ↗️↖️↗️. 到这里如果都能看明白，其他对这个题目解题就很有帮助了。我们接下来要做的就是将四个方向扩展出来的方向列表搞出来，这个可以从二阶扩展到三阶的皮亚诺曲线中得到。</p><ol><li>↗️ 扩展为 ↗️↖️↗️ ↘️↙️↘️ ↗️↖️↗️ 对应编号为 <code>121 343 121</code></li><li>↖️ 扩展为 ↖️↗️↖️ ↙️↘️↙️ ↖️↗️↖️ 对应编号为 <code>212 434 212</code></li><li>↘️ 扩展为 ↘️↙️↘️ ↗️↖️↗️ ↘️↙️↘️ 对应编号为 <code>343 121 343</code></li><li>↙️ 扩展为 ↙️↘️↙️ ↖️↗️↖️ ↙️↘️↙️ 对应编号为 <code>434 212 434</code></li></ol><p>到这里接下来就变得简单了，当然还有一点需要处理，那就是各个大致行走方向怎么接上的问题，比如：先↗️走，接下来需要↖️走，但是我应该怎样让↗️结束后的那个位置接上↖️开始的位置呢？</p><p>那么我们对于所有可能的组合进行的表示（当然并不是所有的方向组合都在这个方向中的，比如↗️接下来就不可能是↙️）：</p><p><img src="https://upload.ismdeep.com/images/2020/11/17/840fb3fcad1124b4846e5eb846c95113-fdd6e7.jpg" alt="J41Ora9ESyuBnG7xh9tvdg_thumb_6b7" style="zoom: 33%;"></p><p>那对于大致方向与大致方向之间的连接关系我们也得到了。</p><p>下来就是把大致方向（↗️、↖️、↘️、↙️）表示成详细的行走方向（⬆️、⬇️、⬅️、➡️）即可。</p><h1 id="3-皮亚诺曲线实现"><a href="#3-皮亚诺曲线实现" class="headerlink" title="3. 皮亚诺曲线实现"></a>3. 皮亚诺曲线实现</h1><p><code>Dir.java</code> 详细行走方向类，后面需要用到。</p><pre><code class="java">public class Dir {    public int ic;    public int jc;    public Dir(int _ic_, int _jc_) {        this.ic = _ic_;        this.jc = _jc_;    }}</code></pre><p><code>DirUtil.java</code> 方向处理工具类，<strong>核心部分</strong>，用于升阶扩展操作，以及将大致行走方向表示成详细的行走方向。</p><pre><code class="java">import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class DirUtil {    private static final Dir UP = new Dir(1, 0);    private static final Dir DOWN = new Dir(-1, 0);    private static final Dir RIGHT = new Dir(0, 1);    private static final Dir LEFT = new Dir(0, -1);    public static Dir[] dir1 = new Dir[]{            UP, UP, RIGHT, DOWN, DOWN, RIGHT, UP, UP    };    public static Dir[] dir2 = new Dir[]{            UP, UP, LEFT, DOWN, DOWN, LEFT, UP, UP    };    public static Dir[] dir3 = new Dir[]{            DOWN, DOWN, RIGHT, UP, UP, RIGHT, DOWN, DOWN    };    public static Dir[] dir4 = new Dir[]{            DOWN, DOWN, LEFT, UP, UP, LEFT, DOWN, DOWN    };    public static Dir[] getDir(DirTester.Point s, DirTester.Point t) {        if (s.x &lt; t.x &amp;&amp; s.y &lt; t.y) return dir1;        if (s.x &lt; t.x &amp;&amp; s.y &gt; t.y) return dir2;        if (s.x &gt; t.x &amp;&amp; s.y &lt; t.y) return dir3;        return dir4;    }    public static Dir[] getDirById(int __id__) {        switch (__id__) {            case 1:                return dir1;            case 2:                return dir2;            case 3:                return dir3;            case 4:                return dir4;        }        return null;    }    // 升阶扩展操作    public static List&lt;Integer&gt; expandDirGroup(List&lt;Integer&gt; list) {        List&lt;Integer&gt; expandedList = new ArrayList&lt;&gt;();        for (int item : list) {            switch (item) {                case 1:                    expandedList.addAll(Arrays.asList(1, 2, 1, 3, 4, 3, 1, 2, 1));                    break;                case 2:                    expandedList.addAll(Arrays.asList(2, 1, 2, 4, 3, 4, 2, 1, 2));                    break;                case 3:                    expandedList.addAll(Arrays.asList(3, 4, 3, 1, 2, 1, 3, 4, 3));                    break;                case 4:                    expandedList.addAll(Arrays.asList(4, 3, 4, 2, 1, 2, 4, 3, 4));                    break;            }        }        return expandedList;    }    // 将大致行走方向展开为完整的行走方向    public static List&lt;Dir&gt; expandAsStepList(List&lt;Integer&gt; dirGroupList) {        List&lt;Dir&gt; dirs = new ArrayList&lt;&gt;();        int prevDirId = 0;        for (int dirGroupId : dirGroupList) {            Dir[] dirsTmp = getDirById(dirGroupId);            switch (prevDirId * 10 + dirGroupId) {                case 12:                case 21:                    dirs.add(UP);                    break;                case 13:                case 31:                    dirs.add(RIGHT);                    break;                case 24:                case 42:                    dirs.add(LEFT);                    break;                case 34:                case 43:                    dirs.add(DOWN);                    break;            }            assert dirsTmp != null;            dirs.addAll(Arrays.asList(dirsTmp));            prevDirId = dirGroupId;        }        return dirs;    }}</code></pre><p><code>HilbertCurveTester.java</code> 则是对曲线结果进行测试了。</p><pre><code class="java">import java.util.*;public class HilbertCurveTester {    static class Point {        public int x, y;        public Point() {        }        public Point(int x, int y) {            this.x = x;            this.y = y;        }    }    public static int[][] genMap(int level) {        if (level &lt; 1) {            return null;        }        int mapSize = pow(3, level);        int[][] a = new int[mapSize][mapSize];        List&lt;Integer&gt; dirGroupList = new ArrayList&lt;&gt;();        dirGroupList.add(1);        for (int i = 2; i &lt;= level; i++) {            dirGroupList = DirUtil.expandDirGroup(dirGroupList);        }        List&lt;Dir&gt; dirList = DirUtil.expandAsStepList(dirGroupList);        int x = 0;        int y = 0;        int val = 1;        a[x][y] = val++;        for (Dir dir : dirList) {            x += dir.ic;            y += dir.jc;            a[x][y] = val++;        }        return a;    }    public static int pow(int a, int n) {        int ans = 1;        for (int i = 0; i &lt; n; i++) {            ans *= a;        }        return ans;    }    public static void display(int[][] a) {        for (int i = a.length - 1; i &gt;= 0; i--) {            for (int j = 0; j &lt; a[i].length; j++) {                System.out.printf(&quot;%2d &quot;, a[i][j]);            }            System.out.println();        }    }    public static void main(String[] args) {        System.out.print(&quot;[n] &gt; &quot;);        Scanner in = new Scanner(System.in);        int n = in.nextInt();        int[][] a = genMap(n);        int sum = 0;        assert a != null;        display(a);    }}</code></pre><pre><code class="text">[n] &gt; 1 3  4  9  2  5  8  1  6  7 </code></pre><pre><code>[n] &gt; 221 22 27 28 33 34 75 76 81 20 23 26 29 32 35 74 77 80 19 24 25 30 31 36 73 78 79 18 13 12 43 42 37 72 67 66 17 14 11 44 41 38 71 68 65 16 15 10 45 40 39 70 69 64  3  4  9 46 51 52 57 58 63  2  5  8 47 50 53 56 59 62  1  6  7 48 49 54 55 60 61 </code></pre><h1 id="4-问题求解过程"><a href="#4-问题求解过程" class="headerlink" title="4. 问题求解过程"></a>4. 问题求解过程</h1><p>接下来我们就可以对生成的皮亚诺曲线进行找规律了，我们可以将所有距离都打了出来，形成一个 $(距离，个数)$ 表示形式。比如：</p><pre><code class="text">[n] &gt; 1(1, 8)(5, 2)(3, 2)</code></pre><p>与给的样例是一样的 $1 \times 8 + 5 \times 2 + 3 \times 2 = 24$</p><pre><code>[n] &gt; 2(1, 80)(3, 20)(5, 20)(11, 6)(13, 6)(31, 2)(33, 2)(35, 2)(37, 2)(39, 2)(41, 2)</code></pre><p>这里与给的样例计算结果也是一样的。</p><p>我发现接下去打表就更长了，规律不好找了。于是我突发奇想，我想着直接把同样个数的数值都给加起来看看。</p><p>于是就有了以下关于不同 $n$ 的计算式子：</p><pre><code>1 (24)        =&gt; 1*8      + 8*22 (816)       =&gt; 1*80     + 8*20     + 24*6     + 216*23 (23496)     =&gt; 1*728    + 8*182    + 24*60    + 216*20    + 648*6    + 5832*24 (647520)    =&gt; 1*6560   + 8*1640   + 24*546   + 216*182   + 648*60   + 5832*20   + 17496*6   + 157464*25 (17601144)  =&gt; 1*59048  + 8*14762  + 24*4920  + 216*1640  + 648*546  + 5832*182  + 17496*60  + 157464*20  + 472392*6  + 4251528*26 (476293776) =&gt; 1*531440 + 8*132860 + 24*44286 + 216*14762 + 648*4920 + 5832*1640 + 17496*546 + 157464*182 + 472392*60 + 4251528*20  + 12754584*6 + 114791256*2</code></pre><p>接下来就是快乐的找规律时间了。</p><p>我们将乘法左右给拆分出来，分成两个列表 <code>list1</code> 和 <code>list2</code></p><p><code>list1</code></p><pre><code>1 (24)        =&gt; 1 82 (816)       =&gt; 1 8 24 2163 (23496)     =&gt; 1 8 24 216 648 58324 (647520)    =&gt; 1 8 24 216 648 5832 17496 1574645 (17601144)  =&gt; 1 8 24 216 648 5832 17496 157464 472392 42515286 (476293776) =&gt; 1 8 24 216 648 5832 17496 157464 472392 4251528 12754584 114791256</code></pre><p><code>list2</code></p><pre><code>1 (24)        =&gt; 8      22 (816)       =&gt; 80     20     6     23 (23496)     =&gt; 728    182    60    20    6    24 (647520)    =&gt; 6560   1640   546   182   60   20   6   25 (17601144)  =&gt; 59048  14762  4920  1640  546  182  60  20  6  26 (476293776) =&gt; 531440 132860 44286 14762 4920 1640 546 182 60 20 6 2</code></pre><p>至此，规律就变得很容易找了。</p><p>这里就不去过多赘述了。见下面的代码吧。</p><h1 id="5-解题代码"><a href="#5-解题代码" class="headerlink" title="5. 解题代码"></a>5. 解题代码</h1><pre><code class="java">import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main {    public static long pow(long a, int n) {        long ans = 1;        for (int i = 0; i &lt; n; i++) {            ans *= a;        }        return ans;    }    public static List&lt;Long&gt; genList1(int n) {        if (n &lt; 1) {            return new ArrayList&lt;&gt;();        }        if (n == 1) {            List&lt;Long&gt; result = new ArrayList&lt;&gt;();            result.add(1L);            result.add(8L);            return result;        }        List&lt;Long&gt; prev = genList1(n - 1);        List&lt;Long&gt; result = new ArrayList&lt;&gt;(prev);        result.add(result.get(result.size() - 1) * 3);        result.add(result.get(result.size() - 1) * 9);        return result;    }    public static List&lt;Long&gt; genList2(int n) {        if (n &lt; 1) {            return new ArrayList&lt;&gt;();        }        if (n == 1) {            List&lt;Long&gt; result = new ArrayList&lt;&gt;();            result.add(8L);            result.add(2L);            return result;        }        List&lt;Long&gt; prev = genList2(n - 1);        List&lt;Long&gt; result = new ArrayList&lt;&gt;();        result.add(pow(9, n) - 1);        result.add(result.get(result.size()- 1) / 4L);        result.add(prev.get(1) * 3);        for (int i = 1; i &lt; prev.size(); i++) {            result.add(prev.get(i));        }        return result;    }    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        int n = in.nextInt();        List&lt;Long&gt; list1 = genList1(n);        List&lt;Long&gt; list2 = genList2(n);        long ans = 0;        for (int i = 0; i &lt; n * 2; i++) {            ans += list1.get(i) * list2.get(i);        }        System.out.println(ans);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;皮亚诺曲线（英语：Peano Curve，也称：希尔伯特曲线，Hilbert Curve）是一条能够填满正方形的曲线。在传统概念中，曲线的数维是1维，正方形是2维的。详细介绍见：&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E7%9A%A
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://ismdeep.com/tags/Algorithm/"/>
    
      <category term="Math" scheme="https://ismdeep.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊 HTTP 状态码 301 和 302 的区别</title>
    <link href="https://ismdeep.com/posts/2020-11-12-talk-about-http-status-code-301-and-302.html"/>
    <id>https://ismdeep.com/posts/2020-11-12-talk-about-http-status-code-301-and-302.html</id>
    <published>2020-11-12T15:56:28.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>今天面试了一个厂子，结果又被问到我不熟悉的知识点了，太久没看 HTTP 状态了，也就知道 200 OK，404 NOT FOUND，500，502 系统异常，巴拉巴拉，对于 302 也就是有一点点印象，完全来自于在调试程序从 Chrome 开发者模式的 http response 中看见过。那么，对于 HTTP 状态码的 301 和 302 都有哪些区别呢？</p><p>首先我们先说一下什么是 HTTP 状态码，其实 HTTP 状态码是服务器用来告诉浏览器每一次 HTTP 访问请求的状态的，比如正常的话就返回 200；而如果用户访问了一个不存在的页面，就会返回 404；而当用户访问了一个页面，而这个页面上由于程序员编写的程序不够健壮，或者是后台某个服务停掉了（比如数据库被人删库了）就会出现 500 错误。</p><div style="text-align: center"><img src="https://upload.ismdeep.com/images/2020/11/13/76b3ee0a96d45e20982a0244627d2273-37c2cc.png" alt="img"></div><p>其中 301 和 302 都是用来进行页面重定向的，所以在说起这两个状态码区别之前，我们先说一说页面重定向。在网页重定向中，其实是指当访问了一个网页，启动跳转至新的网页页面。比如：当你在一个网站中反问个人中心页面，然而这时你并没有登录，于是后台作出重定向页面的反应；接下来你在用户登录页面进行登录操作，登录成功后自动跳转至个人中心页面。而这里使用了不同的重定向页面方式，根据不同的需求场景，开发者也会使用不同的重定向技术。</p><p>常用重定向页面方式有：</p><ul><li>301, “Moved Permanently” 永久重定向，推荐用于 SEO 优化</li><li>302, “Found” or “Moved Temporarily”</li><li>307, “Moved Temporarily” (HTTP 1.1 Only)</li><li>Meta Refresh</li></ul><p>下面我们分三个部分对三种页面重定向方式进行说明。</p><h2 id="301-永久重定向"><a href="#301-永久重定向" class="headerlink" title="301 永久重定向"></a>301 永久重定向</h2><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应放回的若干 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p><p>301 最简单最常用的一个常见应该就是域名跳转了。比如，我们访问 <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> 会自动跳转至 <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> ，这一个访问过程是这样的：发送请求之后，服务器给你返回一个 301 状态码，并在 Response Header 中设置 Location 为。<a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> ，浏览器收到这样的响应自动修改地址栏中的地址，继续访问新的地址。</p><p>注意：301 请求是可以缓存的，也就是说，用户下一次通过浏览器访问 <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> 时，浏览器则直接访问 <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> 了，而不需要再去访问服务器，然后又一次拿到响应。这就是永久重定向的意思。</p><h2 id="302-Found-临时重定向"><a href="#302-Found-临时重定向" class="headerlink" title="302 Found/临时重定向"></a>302 Found/临时重定向</h2><p>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，除非有 Cache-Control 或者是 Expires 说明情况下才可以进行缓存，否则都是不可以缓存的。在不缓存的情况下（默认情况），下一次访问原地址时，浏览器应该继续访问服务器。</p><p>302 一个例子就是上述说的用户访问用户中心的例子，在未登录的情况下，需要重定向至登录页面，而在已经登录的情况下，则需要直接显示已登录后用户中心的页面。这次每一次访问都需要进行判断，所以只能是临时重定向。</p><h2 id="307-临时重定向（HTTP-1-1）"><a href="#307-临时重定向（HTTP-1-1）" class="headerlink" title="307 临时重定向（HTTP 1.1）"></a>307 临时重定向（HTTP 1.1）</h2><p>307 重定向是 302 重定向的 HTTP 1.1 后续版本。当客户端的 POST 请求收到服务端 307 状态码响应时，需要跟用户询问是否应该在新 URI 上发起 POST 方法，也就是说，307 是不会把 POST 转为 GET 的。</p><h2 id="Meta-Refresh"><a href="#Meta-Refresh" class="headerlink" title="Meta Refresh"></a>Meta Refresh</h2><p>这个写过前端代码的同学肯定用过，就是 JavaScript 里面的 <code>location.href = &quot;/profile&quot;;</code> 这样的语句啦。我们继续来说上面说的用户登录的例子。有的用户交互设计是这样的，用户在页面上输入账号密码，点击登录按钮并不是通过页面 POST 数据到某个页面上，而是通过 Ajax 方式进行异步访问，当异步返回数据显示登录成功之后再通过 <code>location.href</code> 方式进行 Meta Refresh.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天面试了一个厂子，结果又被问到我不熟悉的知识点了，太久没看 HTTP 状态了，也就知道 200 OK，404 NOT FOUND，500，502 系统异常，巴拉巴拉，对于 302 也就是有一点点印象，完全来自于在调试程序从 Chrome 开发者模式的 http respo
      
    
    </summary>
    
    
      <category term="Development" scheme="https://ismdeep.com/tags/Development/"/>
    
      <category term="Study" scheme="https://ismdeep.com/tags/Study/"/>
    
  </entry>
  
  <entry>
    <title>高性能编程语言：C，C++，Rust，汇编语言</title>
    <link href="https://ismdeep.com/posts/2020-11-09-fast-programming-languages-c-cpp-rust-and-assembly.html"/>
    <id>https://ismdeep.com/posts/2020-11-09-fast-programming-languages-c-cpp-rust-and-assembly.html</id>
    <published>2020-11-09T23:12:18.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>本文并不是在讨论哪种编程语言更好，而是讨论用于开发最快的服务器端系统软件（例如数据库引擎和 HTTPS 服务器）的最强大的工具集。这类软件有着以下几个特定的属性：</p><ul><li>相对较大的代码库，超过 100,000 行 C 或 C++ 代码。尽管可以用汇编语言编写特定的最“热门”的函数，但用汇编语言编写整个程序是不切实际的。</li><li>数据库和 Web 服务器是关键性支撑软件。多年以来我们已经习惯了使用有 MySQL 和 Nginx 进程的 Linux 系统。有一些<a href="https://github.com/tempesta-tech/tempesta/wiki/High-availability" target="_blank" rel="noopener">简单的高可用</a>最佳实践可以缓解由于可能的奔溃而导致的停机时间，但这是另一篇文章的主题。同时，值得一提的是，如果你真的在乎可用性，那么你应该在假设系统的任何组件随时可能奔溃的前提下构建基础架构，就像 <a href="https://lwn.net/Articles/801871/" target="_blank" rel="noopener">Facebook 是这样做的</a>一样，该公司在最新的 Linux 推出之后，就立刻部署使用了。</li></ul><p>多年来，我们一直在开发使用 <a href="http://tempesta-tech.com/c++-services" target="_blank" rel="noopener">C，C++ 和汇编语言最快的软件</a>。 既然 Rust 一直<a href="https://en.wikipedia.org/wiki/Rust_(programming_language" target="_blank" rel="noopener">“专注于性能”</a>，我们当然对此非常感兴趣。虽然有些怀疑，想想当年 Java 编程语言的兴起：有许多报道表明 JIT 编译产生的代码比 C++ 更快。现在很难出现这种 C++ 比 Java 慢的情况，请参见<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/java.html" target="_blank" rel="noopener">基准测试</a>的例子。还值得一题的是，Java 中的内存垃圾回收（GC）会导致较高的尾部等待时间，并且很难甚至根本无法解决该问题。由于 GC，不能将 Go 语言用于高性能编程。</p><h2 id="C-还是-C-？-或者都是？"><a href="#C-还是-C-？-或者都是？" class="headerlink" title="C 还是 C++ ？ 或者都是？"></a>C 还是 C++ ？ 或者都是？</h2><p>C 语言在系统编程中占着主导地位。操作系统内核是最复杂的系统软件之一，不仅因为它直接与硬件打交道，而且还由于严格的性能要求。Linux 和 FreeBSD 内核以及其他 UNIX 和 Windows 内核都是用 C 编写的。让我们从这个高性能系统软件的出色示例开始进行讨论。</p><h3 id="C-开发操作系统内核"><a href="#C-开发操作系统内核" class="headerlink" title="C++ 开发操作系统内核"></a>C++ 开发操作系统内核</h3><p>FreeBSD <a href="https://forums.freebsd.org/threads/driver-building-in-c.35701/" target="_blank" rel="noopener">已经支持 C++ 模块</a> 有一段时间了。虽然 Linux 内核从不支持 C++，但是有一个用 C++ 编写并用作 Linux 内核模块的 <a href="https://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf" target="_blank" rel="noopener">Click 模块化路由器</a>。如果您对操作系统内核开发的 C++ 适用性感兴趣，那么可以在 <a href="https://wiki.osdev.org/C++" target="_blank" rel="noopener">C++</a> 和 <a href="https://wiki.osdev.org/C++_Bare_Bones" target="_blank" rel="noopener">Bare bones</a> 文章中找到相当不错的讨论。但是，有一些本质的原因反对使用 C++ 进行操作系统内核开发：</p><ul><li>不需要 <code>libstdc++</code> 和 <a href="https://en.wikipedia.org/wiki/Run-time_type_information" target="_blank" rel="noopener">RTTI</a> ，以及内核空间异常处理。事实上，<code>dynamic_cast</code> 并不经常使用，并且有很多 C++ 项目并没有 RTTI 编译。如果需要异常处理，则必须将它们一直到内核中。<code>libstdc++</code> 使用基本的 C 分配，因此必须对内核进行大量修改。</li><li>不能使用 STL 和 Boost 库。实际上，所有内核都已经拥有自己的库。C++ 引入了文件系统，线程和网络库，这在操作系统内核中是毫无意义的。另一方面，现代的操作系统提供了高级同步原语，而这些原语在标准 C++ 中仍然不可用（例如，在 C++ 中仍然没有读写自旋锁）。 </li><li>Linux 内核提供的内存分配的数量（SLAB，页面 <code>vmalloc()</code>, <code>kmalloc()</code> 等），因此你必须使用 <a href="https://en.cppreference.com/w/cpp/language/new" target="_blank" rel="noopener"><code>placement new</code></a> 和/或 只使用 C 函数的内存分配和释放。对齐内存对于提高性能至关重要，但是你需要编写特殊的包装程序才能对齐使用 <code>new</code>.</li><li>当原始内存指针经常被强制转换为某些数据结构时，强类型安全性对于系统编程而言并不那么舒适。尽管还是有争议的：虽然有些人不习惯用冗长的 <code>reinterpret_cast&lt;Foo *&gt;(ptr)</code> 替代不是简短的 <code>(Foo *)ptr</code>. 但其他人却拥有更多的类型和更多的类型安全性。</li><li>命名空间和函数重载，必须要 C++ 的<a href="https://en.wikipedia.org/wiki/Name_mangling" target="_blank" rel="noopener">名称处理</a>。而这使函数很难从汇编调用，因此需要使用 <code>extern &quot;C&quot;</code>. </li><li>你必须为静态对象的构造函数和析构函数 <code>.ctor</code> 以及 <code>.dtor</code> 相应的对象创建特殊的代码段。</li><li>C++ 异常不能跨越<em>上下文</em>边界，即：你不能在一个线程中抛出异常而在另一个线程中捕获它。操作系统内核需要处理更复杂的上下文模型：内核线程，进入内核的用户空间线程，延迟和硬件中断。上下文可以以自愿或合作的方式相互抢占，因此当前上下文的异常处理可以被另一个上下文抢占。还有内存管理和上下文切换代码，它们可能与异常处理代码冲突。就像 RTTI 一样，可以在内核中实现该机制，但是不能使用当前的标准库。</li><li>虽然 Clang 和 G++ 支持 <code>__restrict__</code> 扩展，但是官方的 C++ 标准 <a href="https://www.quora.com/Why-doesnt-C++-have-an-equivalent-of-Cs-restrict-specifier" target="_blank" rel="noopener">不支持</a>.</li><li><a href="https://lwn.net/Articles/749064/" target="_blank" rel="noopener">不鼓励</a> 在 Linux 内核中使用可变长数组（VLA），在某些情况下它们仍然很方便，但是 <a href="https://groups.google.com/g/comp.std.c++/c/K_4lgA1JYeg?pli=1" target="_blank" rel="noopener">在 C++ 中完全不可用</a>。</li></ul><p>因此，在内核空间中使用 C++，基本上只有模版，类继承和一些语法糖（如 lambda 函数）。由于系统代码很少需要复杂的抽象和继承，那么在内核空间中使用 C++ 仍然有意义吗？</p><h3 id="C-异常"><a href="#C-异常" class="headerlink" title="C++ 异常"></a>C++ 异常</h3><p>这是最<a href="https://herbsutter.com/2010/03/13/trip-report-march-2010-iso-c-standards-meeting/" target="_blank" rel="noopener">值得争辩</a> 的 C++ 功能之一，值得写上一章。例如：MySQL 的项目，以下为 <a href="https://google.github.io/styleguide/cppguide.html#Exceptions" target="_blank" rel="noopener">Google 编码风格</a>， <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_CODING_GUIDELINES.html" target="_blank" rel="noopener">不使用异常</a>。Google 编码风格提供了优秀的使用异常的优缺点列表。在这里，我们仅关注性能方面。</p><p>当我们不得不在可能的地方处理错误代码时，异常可以提高性能，例如（让函数内联并且很小）</p><pre><code class="c">if (func_1())    return -EINVAL;if (func_2())    return -EINVAL;....if (func_100())    return -EINVAL;</code></pre><p>该代码的问题是存在额外的条件跳转。现代 CPU 可以很好地进行分支预测，但是仍然会影响性能。在 C++ 中，我们可以编写</p><pre><code class="cpp">try {    func_1();    func_2();    ...    func_100();} catch (...) {    return -EINVAL;}   </code></pre><p>，因此<em>热</em>路径中没有多余的条件。但是，这不是自由的：你的 C++ 代码中的大多数函数都必须带有额外的结尾，这些异常表带有这些函数可以捕获的异常表和适当的清除表。函数结尾没有在正常的工作流中执行，但是它们增加了代码的大小，从而导致 CPU 指令缓存中的额外污染。你可以在 <a href="https://monoinfinito.wordpress.com/series/exception-handling-in-c/" target="_blank" rel="noopener">Nico Brailovsky</a> 的博客中找到有关 C++ 异常处理内部的详细信息。</p><h3 id="C-仍然不错？"><a href="#C-仍然不错？" class="headerlink" title="C++ 仍然不错？"></a>C++ 仍然不错？</h3><p>是的。首先，实际上并不是整个代码都必须尽可能快，并且在大多数情况下，我们不需要自定义内存分配，也不在乎异常开销。大多数项目（尤其是新项目）都是在用户空间中开发的，并且受益于相对丰富的 C++ 标准和 Boost 库（虽然不如 Java 丰富）。</p><p>其次，C++ 最大的特点就是：<strong>它是 C</strong>。如果你不想使用异常或 RTTI，则只需要关闭功能即可。大多数 C 程序都可以使用 C++ 编译器进行编译，只需进行很小的更改或完全不进行任何更改。举个例子，我们只需要这个微不足道的更改</p><pre><code class="bash">$ diff -up nbody.c nbody-new.cc    @@ -112,9 +112,9 @@ static void advance(body bodies[]){         // ROUNDED_INTERACTIONS_COUNT elements to simplify one of the following         // loops and to also keep the second and third arrays in position_Deltas         // aligned properly.    -    static alignas(__m128d) double    -      position_Deltas[3][ROUNDED_INTERACTIONS_COUNT],    -      magnitudes[ROUNDED_INTERACTIONS_COUNT];    +    static double    +      position_Deltas[3][ROUNDED_INTERACTIONS_COUNT] __attribute__((aligned(16))),    +      magnitudes[ROUNDED_INTERACTIONS_COUNT] __attribute__((aligned(16)));         // Calculate the position_Deltas between the bodies for each interaction.         for(intnative_t i=0, k=0; i &lt; BODIES_COUNT-1; ++i)    </code></pre><p>用 G++ 编译器编译 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/nbody-clang-8.html" target="_blank" rel="noopener">C 程序</a> 。现代的 C++ 编译器提供了 C 兼容性扩展，例如 <code>_restrict</code> 关键字。我们总是可以用 C 风格编写 C++ 程序中性能最关键的代码。如果你不喜欢 <a href="https://250bpm.com/blog:8/" target="_blank" rel="noopener">带有额外开销的 STL 容器</a>，则可以使用 <a href="https://www.boost.org/doc/libs/1_74_0/doc/html/intrusive.html" target="_blank" rel="noopener">Boost.intrusive</a> ，或者甚至从 Linux 内核或其他高速 C 项目移植类似的容器。在大多数情况下，这不会感到痛苦。例如，请参阅如何在 C++ <a href="https://github.com/tempesta-tech/blog/tree/master/htrie" target="_blank" rel="noopener">benchmark</a> 中使用 PostgreSQL 的哈希表，<a href="https://github.com/tempesta-tech/tempesta/tree/master/tempesta_db" target="_blank" rel="noopener">Tempesta DB</a> 的 HTrie 以及 Linux 内核读/写自旋锁（全部都是用 C 编写的。）</p><p>关于使用 C++ 编写高性能程序的最后一件事必须提到的是<a href="https://en.wikipedia.org/wiki/Template_metaprogramming" target="_blank" rel="noopener">模板元编程</a>。对于现代 C++ 标准而言，令人兴奋的是，使用模板可以编写非常复杂的逻辑，这些逻辑在编译时就可以完全计算出来，而在运行时则不增加任何负担。</p><h2 id="GOTO-C-的力量所在"><a href="#GOTO-C-的力量所在" class="headerlink" title="GOTO - C 的力量所在"></a>GOTO - C 的力量所在</h2><p><strong>专业的工具必须允许你以最有效的方式使用它。</strong> 高级和高性能的编程语言的目标是生成最高效的机器代码。每种硬件体系结构都支持 <em>jumps</em> 指令，这意味着你可以在任何条件下跳转到任何地址。C 和 C++ 编程语言中最接近跳转的抽象就是<code>goto</code> 操作符。它不像汇编那样灵活 <code>jmp</code> ，但是 C 编译器提供了扩展，使操作符几乎可以完全等同于汇编的 <code>jmp</code>. 不幸的是，Rust <a href="https://internals.rust-lang.org/t/gotos-in-restricted-functions/4393" target="_blank" rel="noopener">并不支持 goto</a>，这使它在整个性能关键性任务中都显得笨拙。</p><p>我们谈论解析器。这里并不是说通过一堆 <code>switch</code> 和 <code>if</code> 语言完美完成的配置文件解析器，而是关于大型且非常快速的解析器（如 HTTP 解析器）。你可能会认为这是 “太狭窄” 或 “太具体” 的任务，但是回想一下解析器生成器，例如 <a href="http://www.colm.net/open-source/ragel/" target="_blank" rel="noopener">Ragel</a> 或 <a href="https://www.gnu.org/software/bison/" target="_blank" rel="noopener">GNU Bison</a>. 如果开发这样的解析器生成器，那么你将永远不知道将出现多大的解析器。（顺便说一下，Ragel 广泛使用 <code>goto</code> 生成非常快的解析器。）还要注意每个 RDMS 中的 SQL 解析器。实际上，我们可以将任务的类别概括为<em>大型和快速的有限状态机</em>，例如：正则表达式。</p><p><a href="https://github.com/tempesta-tech/tempesta/" target="_blank" rel="noopener">Tempesta FW</a>  中的 <a href="https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/http_parser.c" target="_blank" rel="noopener">HTTP 解析器</a> 比其他 Web 服务器中的 HTTP 解析器要大得多，因为，除了基本的 HTTP 解析，也做了很多的安全检查，严格验证对 RFC 的输入。此外，我们的解析器还可以处理零拷贝数据，因此也非常关心数据块。在 <a href="https://www.socallinuxexpo.org/scale/17x/presentations/fast-http-string-processing-algorithms" target="_blank" rel="noopener">SCALE 17x 会议</a>上的演讲中描述了解析器的技术细节，您可以观看<a href="https://youtu.be/LQc4er8ng64?t=25501" target="_blank" rel="noopener">演讲视频</a>或者<a href="http://tempesta-tech.com/research/http_str.pdf" target="_blank" rel="noopener">幻灯片</a>。</p><p>通常，HTTP 解析器被实现为输入字符和嵌套 <code>switch</code> 语句的循环，以获取允许的字符和可用状态。例如 <a href="https://github.com/nginx/nginx/blob/master/src/http/ngx_http_parse.c#L104" target="_blank" rel="noopener"><code>ngx_http_parse_request_line()</code></a> ，请参见 <a href="https://github.com/nginx/nginx/blob/master/src/http/ngx_http_parse.c" target="_blank" rel="noopener">Nginx 解析器源代码</a>。为了简洁其间，让我们考虑一个简化的代码版本：</p><pre><code class="c">while (++str_ptr) {    switch (current_state) {    case 0:        ...    case 1:        ...    ...    case 100:        switch (*str_ptr) {        case &#39;a&#39;:            ...            current_state = 200;            break;        case &#39;b&#39;:            ...            current_state = 101;            break;        }        break;    case 101:        ...    ...    }}</code></pre><p>假设解析器已经完成了对处于状态 <code>100</code> 的先前数据块的解析，而当前数据库从字符 <code>b</code> 开始。不管 <a href="http://tempesta-tech.com/research/http_str.pdf" target="_blank" rel="noopener">switch语句优化</a>（可以由编译器使用查找表或二进制搜索进行优化），代码都存在以下三个问题：</p><ol><li>查找状态 <code>100</code> 仍然比直接跳转更耗时。</li><li>当状态码放置在状态 <code>100</code> 后的状态 <code>101</code> 时，我们必须重新进入 <code>while</code> 和 <code>switch</code> 语句，即再次查找下一个状态，而不是仅一步移动一个字符并直接跳到下一个状态。</li><li>即使我们总是在状态 <code>100</code> 后的状态 <code>101</code>，编译器也可以通过以下方式重新组织代码：将状态 <code>101</code> 放在 <code>switch</code> 语句的开头，而将状态 <code>100</code> 放在语句的末尾。</li></ol><p>Tempesta FW 使用 <code>goto</code> 语句和标签的 GCC 编译器扩展（<a href="https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html" target="_blank" rel="noopener">标签变量</a> 和 <a href="https://gcc.gnu.org/onlinedocs/gcc/Label-Attributes.html" target="_blank" rel="noopener">标签属性</a>）通过以下代码解决了所有问题：</p><pre><code class="c">// Use labels as values to remember the current state when we// exit the state machine at the end of current data chunk.parser-&gt;state = &amp;&amp;state_100;goto *parser-&gt;state;while (true) {state_0:    ...state_1:    ...// The state is placed by a compiler closer to the beginning// of the code.state_100: __attribute__((hot))    // We still use small switches for small character sets.     switch (*str_ptr) {    case &#39;a&#39;:        ...        ++str_ptr;        goto state_200;    case &#39;b&#39;:        ...        ++str_ptr;        // Just fall through to the state 101.    }// This state is placed by the compiler after state_100.state_101: __attribute__((cold))    ...}   </code></pre><p>由于 Rust 不支持 <code>goto</code> 语句，因此我们需要使用汇编语言通过直接跳转和最佳代码布局来实现状态机。</p><h2 id="当汇编比-C-容易时"><a href="#当汇编比-C-容易时" class="headerlink" title="当汇编比 C 容易时"></a>当汇编比 C 容易时</h2><p>现在我们先看一个示例，该示例中的汇编语言不仅可以生成更快的代码，还可以以更有效率的方式编写程序。此示例是关于多精度整数运算。</p><p>公钥密码学和椭圆曲线密码算法尤其依赖大整数运算。Tom St Denis所著的《<a href="https://www.amazon.com/BigNum-Math-Implementing-Cryptographic-Arithmetic/dp/1597491128" target="_blank" rel="noopener">BigNum Math：实现加密多精度算术</a>》一书提供了有关该主题以及许多算法的 C 实现的详细细节，但现在让我们考虑一下 64 位上 128 位长的两个大整数的基本加法机。大整数包括<em>几个块</em>，两个64位 <code>long</code>。为了求和整数，我们必须关心块之间的进位，因此生成的C代码看起来像（参见书中的4.2.1）：</p><pre><code class="c">// a := a + b// x[0] is the less significant limb,// x[1] is the most significant limb.void s_mp_add(unsigned long *a, unsigned long *b){    unsigned long carry;    a[0] += b[0];    carry = (a[0] &lt; b[0]);    a[1] += b[1] + carry;}    </code></pre><p>代码虽小又简单，但是你可能不得不考虑使用进行操作的正确性的 <code>carry</code>。幸运的事，x86-64 是 <a href="https://en.wikipedia.org/wiki/Complex_instruction_set_computer" target="_blank" rel="noopener">CISC</a> 体系结构，它为我们提供了许多计算功能，其中就有带进位的计算，因此上面的代码只用两条指令就可以完成，而无需进行比较：</p><pre><code class="c">// Pointer to a is in %RDI, pointer to b is in %RSImovq    (%rdi), %r8movq    8(%rdi), %r9addq    (%rsi), %r8     // add with carryaddc    8(%rsi), %r9    // use the carry in the next additionmovq    (%r8), (%rdi)movq    (%r9), 8(%rdi)</code></pre><p>如果您查看任何经过优化的加密库，例如 <a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL</a> 或 <a href="https://github.com/tempesta-tech/tempesta/tree/master/tls" target="_blank" rel="noopener">Tempesta TLS</a>，那么您会发现很多汇编代码（OpenSSL实际上使用Perl脚本生成了汇编源代码）。</p><h2 id="Rust-一览"><a href="#Rust-一览" class="headerlink" title="Rust 一览"></a>Rust 一览</h2><p>乍一看，Rust具备开发非常高效的代码的精良装备：<a href="https://doc.rust-lang.org/edition-guide/rust-2018/simd-for-faster-computing.html" target="_blank" rel="noopener">SIMD内在函数</a>，<a href="https://doc.rust-lang.org/reference/type-layout.html" target="_blank" rel="noopener">内存对齐</a>，<a href="https://doc.rust-lang.org/std/sync/atomic/fn.fence.html" target="_blank" rel="noopener">内存屏障</a>，<a href="https://doc.rust-lang.org/1.8.0/book/inline-assembly.html" target="_blank" rel="noopener">内联汇编</a>。Rust 与 C 或 C++ 有很多比较，例如 <a href="https://kornel.ski/rust-c-speed" target="_blank" rel="noopener">Rust与C</a> 或 <a href="https://www.viva64.com/en/b/0733/" target="_blank" rel="noopener">C++ 的速度比 Rust 更快，更安全：Yandex 基准测试</a>。但是，如果你考虑使用 Rust 开发基准测试领先产品，那么您可能会面临一些障碍以及缺少 <code>goto</code> 操作符的麻烦：</p><ul><li>从技术上讲，Rust支持自定义内存分配器，但是存在<a href="https://www.reddit.com/r/rust/comments/80jqvn/allocator_story_in_rust/" target="_blank" rel="noopener">严重的局限性</a>。值得一提的是，任何<a href="https://natsys-lab.blogspot.com/2015/09/fast-memory-pool-allocators-boost-nginx.html" target="_blank" rel="noopener">高性能软件都使用许多临时内存分配器</a>。</li><li>就像 C++ 一样，Rust 不提供 VLA 。但是，如果 C++ 仍然可以使用 <code>alloca(3)</code>，Rust 根本不会提供堆栈分配。太可惜了，因为栈分配是消耗最小的，而由于先前的考虑，自定义内存分配器不是一个选择。</li><li>这似乎<a href="https://doc.rust-lang.org/std/intrinsics/fn.unlikely.html" target="_blank" rel="noopener">可能/不可能</a>支持是比现代的C或C ++编译器强大得多。</li><li>在 Rust 中可以从原始内存读写数据结构，但是比 C 甚至 C++ 需要<a href="https://users.rust-lang.org/t/reading-structures-in-memory-via-pointers/33886" target="_blank" rel="noopener">更多的代码</a>。不过没什么大不了的。</li><li>Rust的<a href="https://doc.rust-lang.org/book/ch10-01-syntax.html" target="_blank" rel="noopener">泛型</a>和<a href="https://doc.rust-lang.org/book/ch19-06-macros.html" target="_blank" rel="noopener">宏</a>功能<a href="https://users.rust-lang.org/t/generic-functions-c-vs-rust/21965/" target="_blank" rel="noopener">远不及</a> C++ 模板和 C 宏所提供的<a href="https://users.rust-lang.org/t/generic-functions-c-vs-rust/21965/" target="_blank" rel="noopener">功能强大</a>。虽然，这也不是那么关键。</li></ul><p>关于Rust系统编程的最关键的失望是它处理原始内存的能力有限，这是内存安全的另一方面。</p><h2 id="C-和-Rust-中的可靠性和安全性"><a href="#C-和-Rust-中的可靠性和安全性" class="headerlink" title="C++ 和 Rust 中的可靠性和安全性"></a>C++ 和 Rust 中的可靠性和安全性</h2><p>如果不解决 Rust 和 C++ 编程语言提供的可靠性和安全性，本文将是不完整的。幸运的是，<a href="https://www.youtube.com/watch?v=_pQGRr4P16w" target="_blank" rel="noopener">Microsoft 的 Sunny Chatterjee 最近在 CppCon 2020上发表了这个话题</a>。Rust的主要好处是内存和并发安全性，但是现代的C ++也解决了这些主题。在本演示中，Sunny 解决了 Rust 与 C++ 之间的以下6个差距：转换，switch 语句，更智能的循环，更智能的复制，生存期和可变性。让我们回顾一下差距。</p><ul><li>带有编译器选项的现代 C 和 C++ 编译器可以很好地处理类型<strong>转换</strong> <code>-Wall</code>。</li><li><strong><code>switch</code></strong>语句也使用进行处理 <code>-Wall</code>。此外，GCC 还<a href="https://lwn.net/Articles/794944/" target="_blank" rel="noopener">引入了</a> <code>-Wimplicit-fallthrough</code>编译器选项，该选项使“通过”明确。</li><li>自 C++ 11起，<strong>更聪明的循环</strong>由基于C ++<a href="https://en.cppreference.com/w/cpp/language/range-for" target="_blank" rel="noopener">范围的for循环解决</a>。</li><li><code>const auto &amp;</code>参考和细粒度的复制和移动语义会注意<strong>智能复制</strong>。</li><li><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" target="_blank" rel="noopener">RAII</a>提供了强大的<strong>生命周期</strong>，但不幸的<em>是并非涵盖所有情况</em>。</li><li><code>const</code>带有或不带有<code>mutable</code>成员，<code>const</code>引用和变量的C ++类提供了细粒度的<strong>可变性</strong>，但是bust也<em>不能涵盖所有情况</em>。</li></ul><p>演示最后以“ <a href="https://github.com/isocpp/CppCoreGuidelines" target="_blank" rel="noopener">C++ 核心准则</a>规定许多重大项目”进行了总结，且现代 C 和 C++ 编译器趋向于实现忽略检查。还值得一提的是，C / C++世界有效地使用了地址清理器（例如，<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank" rel="noopener">ASAN</a>内置于LLVM和GCC编译器的现代版本中）来捕获<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank" rel="noopener">越界</a>内存访问。毕竟，<code>unsafe</code>就像在C ++中使用原始指针一样，您仍然可以使用Rust中的代码来产生错误。</p><h2 id="计算机语言的基准测试"><a href="#计算机语言的基准测试" class="headerlink" title="计算机语言的基准测试"></a>计算机语言的基准测试</h2><p>由于我们在谈论性能，因此我们必须看一下“<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html" target="_blank" rel="noopener">计算机语言基准测试”</a>。要比较不同语言的性能，您需要以相同的方式在所有语言中实现相同的任务。这不是人们通常要做的事情，因此很难找到不同语言的真实代码示例，这些示例使您可以将桔子与桔子进行比较，而不是将桔子与苹果进行比较。虽然Benchmarks游戏是一款游戏，它会比较一些小的特定任务的实现，但这是我们拥有的最好的游戏之一。所述<a href="https://github.com/dmitryikh/rust-vs-cpp-bench" target="_blank" rel="noopener">VS锈比较C ++ 11</a>是C ++和Rust中相等实现的又一比较。Benchmarks游戏中没有汇编语言，但是相应地有Rust（用于G ++编译器的C ++）和两个用于Clang和GCC编译器的C。在撰写本文时，实现的性能为（以秒为单位，越少越好）：</p><table><thead><tr><th style="text-align:left">Problem</th><th style="text-align:left">G++</th><th style="text-align:left">GCC</th><th style="text-align:left">Clang</th><th style="text-align:left">Rust</th></tr></thead><tbody><tr><td style="text-align:left">fannkuch-redux</td><td style="text-align:left">8.07</td><td style="text-align:left">7.53</td><td style="text-align:left">9.45</td><td style="text-align:left"><strong>6.88</strong></td></tr><tr><td style="text-align:left">spectral-norm</td><td style="text-align:left">0.72</td><td style="text-align:left">0.72</td><td style="text-align:left">0.72</td><td style="text-align:left"><strong>0.71</strong></td></tr><tr><td style="text-align:left">n-body</td><td style="text-align:left">4.09</td><td style="text-align:left">4.30</td><td style="text-align:left"><strong>3.31</strong></td><td style="text-align:left"><strong>3.31</strong></td></tr><tr><td style="text-align:left">binary-trees</td><td style="text-align:left"><strong>1.12</strong></td><td style="text-align:left">1.78</td><td style="text-align:left">1.88</td><td style="text-align:left">1.20</td></tr><tr><td style="text-align:left">fasta</td><td style="text-align:left">1.04</td><td style="text-align:left"><strong>0.82</strong></td><td style="text-align:left">0.88</td><td style="text-align:left">0.91</td></tr><tr><td style="text-align:left">pidigits</td><td style="text-align:left"><strong>0.71</strong></td><td style="text-align:left">0.73</td><td style="text-align:left">0.81</td><td style="text-align:left">0.74</td></tr><tr><td style="text-align:left">mandelbrot</td><td style="text-align:left"><strong>0.84</strong></td><td style="text-align:left">1.27</td><td style="text-align:left">2.09</td><td style="text-align:left">0.92</td></tr><tr><td style="text-align:left">regex-redux</td><td style="text-align:left">1.08</td><td style="text-align:left"><strong>0.80</strong></td><td style="text-align:left">0.81</td><td style="text-align:left">1.28</td></tr><tr><td style="text-align:left">reverse-complement</td><td style="text-align:left"><strong>0.63</strong></td><td style="text-align:left">0.87</td><td style="text-align:left">0.98</td><td style="text-align:left">0.75</td></tr><tr><td style="text-align:left">k-nucleotide</td><td style="text-align:left"><strong>1.93</strong></td><td style="text-align:left">3.71</td><td style="text-align:left">6.19</td><td style="text-align:left">3.29</td></tr></tbody></table><p>只有一个测试，第一个测试，其中 Rust 或多或少明显优于 C 和 C++ 实现。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>您可能很好奇，为什么 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-rust-5.html" target="_blank" rel="noopener">Rust中</a> 的 <em>fannkuch-redux</em> <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-rust-5.html" target="_blank" rel="noopener">实现</a>比 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-gcc-5.html" target="_blank" rel="noopener">C 实现</a>更快？我们也是。这两个程序的副本已附在下文：</p><p>C 程序</p><pre><code class="c">// The Computer Language Benchmarks Game// https://salsa.debian.org/benchmarksgame-team/benchmarksgame///// Contributed by Jeremy Zerfas// Based on the Ada program by Jonathan Parker and Georg Bauhaus which in turn// was based on code by Dave Fladebo, Eckehard Berns, Heiner Marxen, Hongwei Xi,// and The Anh Tran and also the Java program by Oleg Mazurov.// This value controls how many blocks the workload is broken up into (as long// as the value is less than or equal to the factorial of the argument to this// program) in order to allow the blocks to be processed in parallel if// possible. PREFERRED_NUMBER_OF_BLOCKS_TO_USE should be some number which// divides evenly into all factorials larger than it. It should also be around// 2-8 times the amount of threads you want to use in order to create enough// blocks to more evenly distribute the workload amongst the threads.#define PREFERRED_NUMBER_OF_BLOCKS_TO_USE 12#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;// intptr_t should be the native integer type on most sane systems.typedef intptr_t intnative_t;int main(int argc, char ** argv){   const intnative_t n=atoi(argv[1]);   // Create and initialize factorial_Lookup_Table.   intnative_t factorial_Lookup_Table[n+1];   factorial_Lookup_Table[0]=1;   for(intnative_t i=0; ++i&lt;=n;)      factorial_Lookup_Table[i]=i*factorial_Lookup_Table[i-1];   // Determine the block_Size to use. If n! is less than   // PREFERRED_NUMBER_OF_BLOCKS_TO_USE then just use a single block to prevent   // block_Size from being set to 0. This also causes smaller values of n to   // be computed serially which is faster and uses less resources for small   // values of n.   const intnative_t block_Size=factorial_Lookup_Table[n]/     (factorial_Lookup_Table[n]&lt;PREFERRED_NUMBER_OF_BLOCKS_TO_USE ?     1 : PREFERRED_NUMBER_OF_BLOCKS_TO_USE);   intnative_t maximum_Flip_Count=0, checksum=0;   // Iterate over each block.   #pragma omp parallel for \     reduction(max:maximum_Flip_Count) reduction(+:checksum)   for(intnative_t initial_Permutation_Index_For_Block=0;     initial_Permutation_Index_For_Block&lt;factorial_Lookup_Table[n];     initial_Permutation_Index_For_Block+=block_Size){      intnative_t count[n];      int8_t temp_Permutation[n], current_Permutation[n];      // Initialize count and current_Permutation.      count[0]=0;      for(intnative_t i=0; i&lt;n; ++i)         current_Permutation[i]=i;      for(intnative_t i=n-1,        permutation_Index=initial_Permutation_Index_For_Block; i&gt;0; --i){         const intnative_t d=permutation_Index/factorial_Lookup_Table[i];         permutation_Index=permutation_Index%factorial_Lookup_Table[i];         count[i]=d;         for(intnative_t j=0; j&lt;n; ++j)            temp_Permutation[j]=current_Permutation[j];         for(intnative_t j=0; j&lt;=i; ++j)            current_Permutation[j]= j+d&lt;=i ?              temp_Permutation[j+d] : temp_Permutation[j+d-i-1];      }      // Iterate over each permutation in the block.      const intnative_t last_Permutation_Index_In_Block=        initial_Permutation_Index_For_Block+block_Size-1;      for(intnative_t permutation_Index=initial_Permutation_Index_For_Block; ;        ++permutation_Index){         // If the first value in the current_Permutation is not 1 (0) then         // we will need to do at least one flip for the current_Permutation.         if(current_Permutation[0]&gt;0){            // Make a copy of current_Permutation[] to work on. Note that we            // don&#39;t need to copy the first value since that will be stored            // in a separate variable since it gets used a lot.            for(intnative_t i=0; ++i&lt;n;)               temp_Permutation[i]=current_Permutation[i];            intnative_t flip_Count=1;            // Flip temp_Permutation until the element at the first_Value            // index is 1 (0).            for(intnative_t first_Value=current_Permutation[0];              temp_Permutation[first_Value]&gt;0; ++flip_Count){               // Record the new_First_Value and restore the old               // first_Value at its new flipped position.               const int8_t new_First_Value=temp_Permutation[first_Value];               temp_Permutation[first_Value]=first_Value;               // If first_Value is greater than 3 (2) then we are flipping               // a series of four or more values so we will also need to               // flip additional elements in the middle of the               // temp_Permutation.               if(first_Value&gt;2){                  intnative_t low_Index=1, high_Index=first_Value-1;                  // Note that this loop is written so that it will run at                  // most 16 times so that compilers will be more willing                  // to unroll it. Consequently this won&#39;t work right when                  // n is greater than 35. This would probably be the                  // least of your concerns since 21! won&#39;t fit into 64                  // bit integers and even if it did you probably wouldn&#39;t                  // want to run this program with a value that large                  // since it would take thousands of years to do on a                  // modern desktop computer. ;-)                  do{                     const int8_t temp=temp_Permutation[high_Index];                     temp_Permutation[high_Index]=                       temp_Permutation[low_Index];                     temp_Permutation[low_Index]=temp;                  }while(low_Index+++3&lt;=high_Index-- &amp;&amp; low_Index&lt;16);               }               // Update first_Value to new_First_Value that we recorded               // earlier.               first_Value=new_First_Value;            }            // Update the checksum.            if(permutation_Index%2==0)               checksum+=flip_Count;            else               checksum-=flip_Count;            // Update maximum_Flip_Count if necessary.            if(flip_Count&gt;maximum_Flip_Count)               maximum_Flip_Count=flip_Count;         }         // Break out of the loop when we get to the         // last_Permutation_Index_In_Block.         if(permutation_Index&gt;=last_Permutation_Index_In_Block)            break;         // Generate the next permutation.         int8_t first_Value=current_Permutation[1];         current_Permutation[1]=current_Permutation[0];         current_Permutation[0]=first_Value;         for(intnative_t i=1; ++count[i]&gt;i;){            count[i++]=0;            const int8_t new_First_Value=current_Permutation[0]=              current_Permutation[1];            for(intnative_t j=0; ++j&lt;i;)               current_Permutation[j]=current_Permutation[j+1];            current_Permutation[i]=first_Value;            first_Value=new_First_Value;         }      }   }   // Output the results to stdout.   printf(&quot;%jd\nPfannkuchen(%jd) = %jd\n&quot;, (intmax_t)checksum, (intmax_t)n,     (intmax_t)maximum_Flip_Count);   return 0;}</code></pre><p>Rust 程序</p><pre><code class="rust">// The Computer Language Benchmarks Game// https://salsa.debian.org/benchmarksgame-team/benchmarksgame///// Contributed by Cliff L. Biffle, translated from Jeremy Zerfas&#39;s C program.//// The C program was based on the Ada program by Jonathan Parker and Georg// Bauhaus which in turn was based on code by Dave Fladebo, Eckehard Berns,// Heiner Marxen, Hongwei Xi, and The Anh Tran and also the Java program by Oleg// Mazurov.extern crate rayon;use rayon::prelude::*;use std::mem::replace;// This value controls how many blocks the workload is broken up into (as long// as the value is less than or equal to the factorial of the argument to this// program) in order to allow the blocks to be processed in parallel if// possible. PREFERRED_NUMBER_OF_BLOCKS_TO_USE should be some number which// divides evenly into all factorials larger than it. It should also be around// 2-8 times the amount of threads you want to use in order to create enough// blocks to more evenly distribute the workload amongst the threads.const PREFERRED_NUMBER_OF_BLOCKS_TO_USE: usize = 12;// One greater than the maximum `n` value. Used to size stack arrays.const MAX_N: usize = 16;fn main() {    let n = std::env::args().nth(1).unwrap().parse().unwrap();    // This assert eliminates several bounds checks.    assert!(n &lt; MAX_N);    // Create and initialize factorial_lookup_table.    let factorial_lookup_table = {        let mut table: [usize; MAX_N] = [0; MAX_N];        table[0] = 1;        for i in 1..MAX_N {            table[i] = i * table[i - 1];        }        table    };    // Determine the block_size to use. If n! is less than    // PREFERRED_NUMBER_OF_BLOCKS_TO_USE then just use a single block to prevent    // block_size from being set to 0. This also causes smaller values of n to    // be computed serially which is faster and uses less resources for small    // values of n.    let block_size =        1.max(factorial_lookup_table[n] / PREFERRED_NUMBER_OF_BLOCKS_TO_USE);    let block_count = factorial_lookup_table[n] / block_size;    // Iterate over each block.    let (checksum, max_flip_count) = (0..block_count)        .into_par_iter()        .map(|bn| {            let initial_permutation_index = bn * block_size;            let mut count: [usize; MAX_N] = [0; MAX_N];            let mut current_permutation: [u8; MAX_N] =                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];            // Initialize count and current_permutation.            {                let mut temp_permutation: [u8; MAX_N] = [0; MAX_N];                let mut permutation_index = initial_permutation_index;                for i in (1..n).rev() {                    let f = factorial_lookup_table[i];                    let d = permutation_index / f;                    count[i] = d;                    // Rotate the permutation left by d places. This is faster                    // than using slice::rotate_left.                    temp_permutation[0..=i - d]                        .copy_from_slice(&amp;current_permutation[d..=i]);                    temp_permutation[i - d + 1..=i]                        .copy_from_slice(&amp;current_permutation[..d]);                    current_permutation = temp_permutation;                    permutation_index = permutation_index % f;                }            }            let mut max_flip_count = 0;            let mut checksum = 0;            // Iterate over each permutation in the block.            let last_permutation_index = initial_permutation_index + block_size;            for permutation_index in                initial_permutation_index..last_permutation_index            {                // If the first value in the current_permutation is not 1 (0)                // then we will need to do at least one flip for the                // current_permutation.                if current_permutation[0] &gt; 0 {                    // Make a copy of current_permutation[] to work on.                    let mut temp_permutation = current_permutation;                    let mut flip_count: usize = 1;                    // Flip temp_permutation until the element at the                    // first_value index is 1 (0).                    let mut first_value = current_permutation[0] as usize &amp; 0xF;                    while temp_permutation[first_value] &gt; 0 {                        // Record the new_first_value and restore the old                        // first_value at its new flipped position.                        let new_first_value = replace(                            &amp;mut temp_permutation[first_value],                            first_value as u8,                        );                        // If first_value is greater than 3 (2) then we are                        // flipping a series of four or more values so we will                        // also need to flip additional elements in the middle                        // of the temp_permutation.                        if first_value &gt; 2 {                            for (low_index, high_index) in                                (1..first_value).zip((1..first_value).rev())                            {                                temp_permutation.swap(high_index, low_index);                                if low_index + 3 &gt; high_index {                                    break;                                }                            }                        }                        // Update first_value to new_first_value that we                        // recorded earlier.                        first_value = new_first_value as usize &amp; 0xF;                        flip_count += 1;                    }                    // Update the checksum.                    if permutation_index % 2 == 0 {                        checksum += flip_count;                    } else {                        checksum -= flip_count;                    }                    // Update max_flip_count if necessary.                    max_flip_count = max_flip_count.max(flip_count);                }                // Generate the next permutation.                current_permutation.swap(0, 1);                let mut first_value = current_permutation[0];                for i in 1..MAX_N - 2 {                    count[i] += 1;                    if count[i] &lt;= i {                        break;                    }                    count[i] = 0;                    let new_first_value = current_permutation[1];                    for j in 0..i + 1 {                        current_permutation[j] = current_permutation[j + 1];                    }                    current_permutation[i + 1] = first_value;                    first_value = new_first_value;                }            }            (checksum, max_flip_count)        })        .reduce(            || (0, 0),            |(cs1, mf1), (cs2, mf2)| (cs1 + cs2, mf1.max(mf2)),        );    // Output the results to stdout.    println!(&quot;{}&quot;, checksum);    println!(&quot;Pfannkuchen({}) = {}&quot;, n, max_flip_count);}</code></pre><p>让我们启动C程序，并使用<a href="https://perf.wiki.kernel.org/index.php/Main_Page" target="_blank" rel="noopener">Linux perf工具</a>收集该程序的性能概况。我们可以通过程序中最热门的代码<code>perf report</code>或看到<code>perf annotate</code>什么：</p><pre><code class="c">    0.46 |       movzbl    -0x9(%r15,%rax,1),%ecx    0.96 |       movzbl    0x9(%r15),%r8d         |       mov       %r8b,-0x9(%r15,%rax,1)    2.31 |       mov       %cl,0x9(%r15)         |       lea       -0xa(%rax),%rcx   12.76 |       cmp       $0xb,%rdi</code></pre><p>性能杀手获得了12.76％的时间是展开循环的一部分</p><pre><code class="c">do{   const int8_t temp=temp_Permutation[high_Index];   temp_Permutation[high_Index]=     temp_Permutation[low_Index];   temp_Permutation[low_Index]=temp;}while(low_Index+++3&lt;=high_Index-- &amp;&amp; low_Index&lt;16);</code></pre><p>和<code>cmp</code>指令的部分<code>while</code>循环条件。实际上，他的循环只是反转数组中的字节。尽管C实现使用带有数组索引的朴素操作和繁重操作，而Rust实现使用<a href="https://users.rust-lang.org/t/how-to-zip-two-slices-efficiently/2048/2" target="_blank" rel="noopener">高效的double迭代器</a>：</p><pre><code class="c">if first_value &gt; 2 {    for (low_index, high_index) in        (1..first_value).zip((1..first_value).rev())    {        temp_permutation.swap(high_index, low_index);        if low_index + 3 &gt; high_index {            break;        }    }}</code></pre><p><a href="https://dev.to/wunk/fast-array-reversal-with-simd-j3p" target="_blank" rel="noopener">使用SIMD进行快速阵列反转！</a>介绍了几种提高C程序性能的方法（本文使用C ++）。第一种是只使用一个索引<code>i</code>和迭代仅直到与所述阵列的经置换的部分的中间<code>temp_Permutation[i]</code>和<code>temp_Permutation[high_Index - i]</code>。那将与Rust双迭代器非常接近。顺便说一下，提高两个程序性能的更高级的方法是使用<code>PSHUFB</code>SSSE3指令或<code>_mm_shuffle_epi8()</code>内部指令，而不是整个循环。由于混洗掩码的数量很少，因此可以在编译时定义所有混洗掩码，然后将它们立即加载到指令的控制掩码寄存器中。</p><p>但是，这不是实现之间的唯一区别。Rust程序利用最大输入数<code>const MAX_N: usize = 16</code>。由于编译器现在可以对循环和静态数组进行更好的优化，因此这种小的改进可能对性能的影响最大。该程序显式使用静态数组初始化 </p><pre><code class="c">let mut current_permutation: [u8; MAX_N] =    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];</code></pre><p>, 而 C 实现在运行时无需输入数据即可进行此操作</p><pre><code class="c">for(intnative_t i=0; i&lt;n; ++i)   current_Permutation[i]=i;</code></pre><p>Rust 程序使用内置内存复制功能复制阵列</p><pre><code class="c">let mut temp_permutation = current_permutation;</code></pre><p>，而 C 程序再次循环执行此操作</p><pre><code class="c">for(intnative_t i=0; ++i&lt;n;)   temp_Permutation[i]=current_Permutation[i];</code></pre><p>这些并不是C程序中的所有低效率，在Rust实施中已将其消除（这两个程序都基于相同的初始Ada程序）。在大多数地方，该程序的优化版本不仅会更快，而且会更短。</p><p>因此，在这种情况下，当Rust实现的速度快于C时，性能的差异不是关于更好的编译器，而是关于程序的更有效的结构，这使编译器可以更好地优化代码。</p><h2 id="Rust-作为系统编程语言？"><a href="#Rust-作为系统编程语言？" class="headerlink" title="Rust 作为系统编程语言？"></a>Rust 作为系统编程语言？</h2><p><strong>真正的高级系统编程语言必须与C兼容。</strong>仅考虑我们现实生活项目中的2个示例。</p><p>第一个是Web应用程序防火墙（WAF）。这种软件<a href="http://tempesta-tech.com/blog/waf-acceleration" target="_blank" rel="noopener">通常基于Nginx或HAproxy</a> HTTPS服务器（它们是用C编写）<a href="http://tempesta-tech.com/blog/waf-acceleration" target="_blank" rel="noopener">构建的。为Nginx</a>编写 C++ 模块很容易，但是我们需要额外的粘合代码才能在Rust中开发该模块并维护所有补丁。 Nginx的C代码。相同的开发人员可以轻松地在代码的C和C ++部分之间切换。</p><p>在第二种情况下，我们的客户希望使用<a href="https://github.com/mysqludf/lib_mysqludf_sys" target="_blank" rel="noopener">MySQL用户定义函数（UDF）</a>与操作系统进行交互来执行一些外部逻辑。我们可以用任何编程语言开发逻辑，但是有一个限制：我们必须在每个CPU内核上每秒执行5000个程序！即使使用<code>posix_spawnp()</code>Linux中执行程序的最快方法，也无法实现这一点。我们最终为MySQL开发了一个自定义UDF，这是一个加载到MySQL服务器进程中的共享对象。使用C ++非常简单。</p><p>将Rust用作Nginx模块的一个相反的示例是CloudFlare的<a href="https://github.com/cloudflare/quiche" target="_blank" rel="noopener">Quiche</a>，这是一种Nginx扩展，支持QUIC和HTTP / 3协议。尽管绝对可以将Rust用于此类任务，但是除了用于<a href="https://github.com/cloudflare/quiche/issues/6" target="_blank" rel="noopener">C / C ++绑定</a>的<a href="https://github.com/cloudflare/quiche/blob/master/src/ffi.rs" target="_blank" rel="noopener">FFI代码</a>之外，这些家伙仍然必须编写一些C代码来<a href="https://github.com/cloudflare/quiche/blob/master/extras/nginx/nginx-1.16.patch" target="_blank" rel="noopener">修补Nginx</a>。这意味着：</p><ul><li>您必须为 C / C++ 绑定编写一些额外的样板代码</li><li>而且您仍然必须处理 C / C++ <strong>和</strong> 第二种语言，这使项目更加复杂。</li></ul><p>（顺便说一下，同样适用于<a href="https://dlang.org/" target="_blank" rel="noopener">D编程语言</a>，它也不能直接包含C标头。）Quiche项目中的FFI和Nginx补丁程序仅约5,000行代码，即整个代码的10％项目，这是40,000行Rust代码。如果该项目是用C或C ++开发的，那么他们也将需要Nginx补丁，但是不需要第二语言。但是在Nginx主代码库中采用代码的机会为零。这就是实际发生的情况：Nginx团队<a href="https://www.nginx.com/blog/introducing-technology-preview-nginx-support-for-quic-http-3/" target="_blank" rel="noopener">拥有</a>大供应商的生产就绪QUIC实现，因此开发<a href="https://www.nginx.com/blog/introducing-technology-preview-nginx-support-for-quic-http-3/" target="_blank" rel="noopener">了自己的C实现</a>。很难说“绑定”代码是可以忽略的还是开发人员在样板代码上花费了多少时间。问题是，Rust内存安全性（现代核心C ++，静态分析和地址清理器也可以实现）是否使开发如此高效，以至于额外的代码和以两种不同语言维护的代码库变得可以忽略不计？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们意识到，在为Tempesta FW开发<a href="https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/http_parser.c" target="_blank" rel="noopener">HTTP解析器</a>时，我们达到了C语言的极限：如果没有在<code>switch</code>语句中进行查找，就无法直接跳到解析器的所需状态，也无法获得令人满意的代码布局。那时我们考虑将内联汇编引入解析器的代码中。零拷贝状态机已经非常复杂，我们对此想法不满意。在编译器扩展中找到计算的标签和热/冷属性真是太令人惊讶了！由于这些功能，编译器为解析器生成了最佳代码。</p><p><a href="https://en.wikipedia.org/wiki/There&#39;s_more_than_one_way_to_do_it" target="_blank" rel="noopener">TIMTOWTDI</a>表示C ++的强大功能是“有多种方法可以做到” 。是的，这是Perl的想法，但是在很多情况下，C ++允许您使用高级STL或经过优化的自定义算法和数据结构，以纯C语言，在模板元编程中编写程序。现代C ++非常复杂，需要多年的经验才能熟练使用该语言，但是它是一种专业工具，可以使专业开发人员创建最快，最可靠的软件。</p><p>不仅Rust不成熟，而且语言设计者似乎故意限制了语言。有许多不良的程序在滥用<code>goto</code>，因此它们只是删除了运算符：对初级用户有利，但对专业人员而言太有限了。当您在复杂的技术任务中苦苦挣扎时，语言和编译器不可能给您带来惊喜。取而代之的是，当您需要做一些简单的事情时，很可能是您在C或C ++时代所做的事情，您会感到失望，并开始与编译器抗争。作为一个例子，<code>likely</code>和<code>unlikely</code>编译器提示在Linux内核的年龄和使用它们在用户空间C / C ++编程如此流行，它们被<a href="https://en.cppreference.com/w/cpp/language/attributes/likely" target="_blank" rel="noopener">包含在C ++ 20</a>标准（在程序员不得不使用编译器内部函数之前）。但是使用Rust，您会发现<a href="https://doc.rust-lang.org/std/intrinsics/fn.unlikely.html" target="_blank" rel="noopener">该API是试验性的，<code>if</code>仅适用于语句</a>。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://tempesta-tech.com/blog/waf-acceleration" target="_blank" rel="noopener">Web应用程序防火墙加速</a><br>从我们在开发Web应用程序防火墙（WAF）的自定义核心逻辑方面的经验，我们了解到大多数或什至所有现代WAF典型的一些性能问题，这些问题可能导致高昂的拥有成本和/或拒绝服务。在本文中，我们介绍了WAF加速器，它与Web加速器一样，可以提高WAF的性能并保护其免受DDoS攻击。</p><p><a href="http://tempesta-tech.com/blog/natsys-lab-blog" target="_blank" rel="noopener">回顾 NatSys Lab. 博客</a><br>我们回顾了自2011年以来最古老的 NatSys Laboratory 博客中最有趣的帖子：最近的 CPU 漏洞对 Linux 系统调用性能的影响，深入研究HTTP代理功能以及使用 Nginx 和 HAProxy 的 Tempesta FW 的性能比较，快速字符串处理算法，无锁数据结构和内存分配器。很多技术细节！</p><p>转载自：<a href="http://tempesta-tech.com/blog/fast-programming-languages-c-c++-rust-assembly" target="_blank" rel="noopener">http://tempesta-tech.com/blog/fast-programming-languages-c-c++-rust-assembly</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文并不是在讨论哪种编程语言更好，而是讨论用于开发最快的服务器端系统软件（例如数据库引擎和 HTTPS 服务器）的最强大的工具集。这类软件有着以下几个特定的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相对较大的代码库，超过 100,000 行 C 或 C++ 代码。尽管可以用汇编语言
      
    
    </summary>
    
    
      <category term="Hacker" scheme="https://ismdeep.com/tags/Hacker/"/>
    
      <category term="C" scheme="https://ismdeep.com/tags/C/"/>
    
      <category term="Rust" scheme="https://ismdeep.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>时间管理的8个高效经验</title>
    <link href="https://ismdeep.com/posts/2020-10-29-8-experiences-for-efficient-time-management.html"/>
    <id>https://ismdeep.com/posts/2020-10-29-8-experiences-for-efficient-time-management.html</id>
    <published>2020-10-29T12:38:50.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>同样是拥有一天24小时，我们中的一些人似乎比其他人更能充分地利用这些时间。时间管理是做计划、有意识地控制时间的能力。它需要“有意识”地控制，因为我们的注意力一旦转移，时间就会花在别的东西上面（比如你的手机）。</p><h2 id="复盘的力量"><a href="#复盘的力量" class="headerlink" title="复盘的力量"></a>复盘的力量</h2><ul><li>高效利用现有资源</li><li>更加明确环境和目标</li></ul><p>我个人认为，回顾和复盘是你做任何一个项目最有价值的一部分之一。通过分析与复盘能够让你更加清晰的知道这次实践中超出预期以及需要改进和提升的地方。当然最有价值的就是，通过分析不太满意的地方得到的有建设性的 Action。这些 Action 可以帮助你在下一次实践中，做出更好的改变。</p><h2 id="单线程执行"><a href="#单线程执行" class="headerlink" title="单线程执行"></a>单线程执行</h2><ul><li>合理分配时间，一次只做好一件事。</li></ul><p>尽可能保证一段时间内，只做一件事情。当我们进入到做一件事情的 Flow 当中，这时候突然出现一件事情打断，我们回来再继续做这件事情的时候，同样需要一个恢复到 Flow 状态的时间，这样会一定程度上降低我们的效率。</p><h2 id="限定时间"><a href="#限定时间" class="headerlink" title="限定时间"></a>限定时间</h2><ul><li>有 DDL，才有动力</li></ul><p>首先对于自己，我们会更加清晰的知道完成这个任务所要花费的时间。在整个任务时间轴上，估算出完成的时间点之后，可以更加合理的安排剩下的任务。</p><p>对于合作的同事，也可以准确的知道你完成的时间以及和你对接的时间点。在大家约定好的前提下，可以更加高效的促进整个任务的完成。</p><h2 id="拆分任务"><a href="#拆分任务" class="headerlink" title="拆分任务"></a>拆分任务</h2><ul><li>按优先级有序化分，缓解压力与焦虑</li></ul><p>当我们拿到一个非常大的任务，且知道里面有比较有挑战的事情的时候，第一时间的反应是有些焦虑和压力的，因为这个时候只知道我们最终要达到的目标和有挑战的事情，对整个任务的规划和时间预估都是不清晰的。</p><p>这个时候我们需要做的，就是拆分任务。将一个比较大的任务拆分成可预估的小任务，并且按照优先级排序。而且在我们完成每一个小任务的过程中，给到自己很多正向的反馈，帮助我们建立信心，而且对还没有完成的部分也有很清晰的认知，有助于我们更高效的完成这个任务。</p><h2 id="ToDoList"><a href="#ToDoList" class="headerlink" title="ToDoList"></a>ToDoList</h2><ul><li>每时每刻清晰的知道我们的当下任务和进度</li><li>进入到工作和学习状态的一种仪式感</li></ul><p>每天早上，进入工作状态之前，我会写下今日份的 ToDoList ，一般会用两种方式。小本子，写好就打开放在桌面上。或者是用便签纸，写好我会贴到显示器上。这样我就可以随时随地的知道我今天要做哪些任务、现在的进度是怎样的以及还有哪些事情没有开始进行。</p><p>这样对于我来说，每次看到这个 ToDoList 我都对今天要完成的事情很清晰，而且一般 List 的顺序也都是按照优先级有序排列的，如果有事情想要插入进来我也可以很清晰的知道，这一天的时间是否足够，如果插入新任务，放在哪个位置比较合理。</p><h2 id="大局观意识"><a href="#大局观意识" class="headerlink" title="大局观意识"></a>大局观意识</h2><ul><li>结果导向</li><li>跳出细节看整体</li></ul><p>无论是工作还是学习当中，我们很容易由于过于专注陷入到一个 Flow 中无法自拔，当然这是一件很好的事情，说明我们注意力集中，在完成这件事情上完全投入。但也别忘记，在忙碌中需要找到合适的时间，跳出现有的细节来看整体。</p><p>比如现在花费的时间是不是和预期相符，是不是在按照优先级有序的进行，整体的规划是否需要调整等等。</p><h2 id="懂得拒绝，学会说不"><a href="#懂得拒绝，学会说不" class="headerlink" title="懂得拒绝，学会说不"></a>懂得拒绝，学会说不</h2><ul><li>懂得拒绝，将主动权掌握在自己手上</li></ul><p>学会说不，在适当的时候懂得拒绝。尤其是在自己比较紧急的事情没有做完的前提下，一定要分清事情的主次。而且需要确定职责范围，是否是自己可以触及到的领域和范围。</p><p>这一点在初入职场的朋友身上尤为常见，因为刚入公司，在其他同事寻求自己帮助的时候，不太好意思拒绝。我见过很多实习生和刚入职的朋友，因为不懂得拒绝，压缩自己的时间默默加班完成。还有一些职场新人，因为帮助同事，触及到了自己不应该触及的领域，不是说职责范围外的事情就不能帮忙，而是我们需要非常清楚的上下游关系，可能有更合适处理这个问题的同时，所以当别人寻求我们帮助的时候我们也需要理性的进行分析。</p><h2 id="拒绝低质量的勤奋"><a href="#拒绝低质量的勤奋" class="headerlink" title="拒绝低质量的勤奋"></a>拒绝低质量的勤奋</h2><ul><li>要么提高效率，要么暂时放弃</li></ul><p>当你被一个问题困扰了很长时间（且这个时间远远超过了预期），这个时候很有可能你已经进入了一个状态不好的循环当中而不自知。</p><p>比如预期一个小时想要解决的问题三个小时都没有解决，或者想要下班之前解决的问题，到了下班这个时间点还没有解决，不免会陷入到纠结又很焦虑的状态里面，有可能会导致事情越做效率越低。</p><p>这个时候我们最应该做的是要么提高效率要么暂时放弃，我们需要勇敢的放下手头的事情，及时作出一些调整和改变，从而可以让每一份花费的时间都可以凸显出它的价值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;同样是拥有一天24小时，我们中的一些人似乎比其他人更能充分地利用这些时间。时间管理是做计划、有意识地控制时间的能力。它需要“有意识”地控制，因为我们的注意力一旦转移，时间就会花在别的东西上面（比如你的手机）。&lt;/p&gt;
&lt;h2 id=&quot;复盘的力量&quot;&gt;&lt;a href=&quot;#复盘的
      
    
    </summary>
    
    
      <category term="Study" scheme="https://ismdeep.com/tags/Study/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中 screen 常用命令</title>
    <link href="https://ismdeep.com/posts/2020-10-29-intro-to-linux-screen-command.html"/>
    <id>https://ismdeep.com/posts/2020-10-29-intro-to-linux-screen-command.html</id>
    <published>2020-10-29T10:24:46.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>本文要介绍如何使用 Screen 命令来操作 Linux 命令行，让工作更有效率。</p><p>我想，很多同学在使用 Linux 命令行都会有以下这些的需求或者是困惑：</p><ul><li>如何让一个程序后台运行？</li><li>程序后台运行，但是我还想偶尔来看一下程序运行的进度，该怎么弄呢？</li><li>这个要运行的程序并不是我自己写的，我无法通过修改代码来实现后台运行，并把进度输出到日志文件，该怎么办呢？</li><li>要是有一款能够像图形化可以让程序运行在 Terminal 终端中，我想看的时候解锁一下屏幕就好了。</li></ul><p>以上这些困惑也是笔者经常遇到的一个问题，今天就来跟大家介绍一下一个 Linux 命令行下非常好用的一个工具 —— screen.</p><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>Screen 是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。GNU Screen 可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。</p><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p><h2 id="0x01-常见用法"><a href="#0x01-常见用法" class="headerlink" title="0x01 常见用法"></a>0x01 常见用法</h2><p>笔者最常用的用法就是：创建一个screen会话，并在会话中执行程序，通过Ctrl+A D将会话挂在后台运行，需要查看程序运行进度时候通过 <code>screen -r {session_name}</code> 命令恢复会话进行查看即可。</p><p>下面我们就来讲讲这个过程中我们所用到的命令：</p><ul><li><code>screen -S {session_name}</code> 创建一个 screen 会话，需要指定会话名称。比如：<code>screen -S c9</code></li><li><code>screen -r {session_name}</code> 恢复后台运行的 screen 会话。</li><li><code>screen -list</code> 或者 <code>screen -ls</code> 列出当前所有的会话列表。</li></ul><p><strong>注：</strong>在 screen 会话中，通过 Ctrl+A D 快捷键可以将会话分离至后台运行。</p><p>以上者三个命令我相信已经够大部分同学使用了。</p><h2 id="0x02-更多用法"><a href="#0x02-更多用法" class="headerlink" title="0x02 更多用法"></a>0x02 更多用法</h2><p>完整的官方文档在此：<a href="https://www.gnu.org/software/screen/manual/" target="_blank" rel="noopener">https://www.gnu.org/software/screen/manual/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文要介绍如何使用 Screen 命令来操作 Linux 命令行，让工作更有效率。&lt;/p&gt;
&lt;p&gt;我想，很多同学在使用 Linux 命令行都会有以下这些的需求或者是困惑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何让一个程序后台运行？&lt;/li&gt;
&lt;li&gt;程序后台运行，但是我还想偶尔来看
      
    
    </summary>
    
    
      <category term="Hacker" scheme="https://ismdeep.com/tags/Hacker/"/>
    
      <category term="Linux" scheme="https://ismdeep.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>写论文必备软件列表</title>
    <link href="https://ismdeep.com/posts/2020-10-26-softwares-for-writing-papers.html"/>
    <id>https://ismdeep.com/posts/2020-10-26-softwares-for-writing-papers.html</id>
    <published>2020-10-26T10:17:29.000Z</published>
    <updated>2021-06-25T02:16:29.922Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要列出了一些笔者常用的写论文软件。</p><ol><li><p>Office 2013</p><pre><code class="text">ed2k://|file|SW_DVD5_Office_Professional_Plus_2013_64Bit_ChnSimp_MLF_X18-55285.ISO|958879744|678EF5DD83F825E97FB710996E0BA597|/</code></pre></li></ol><ol start="2"><li><p>Visio 2013</p><pre><code class="text">ed2k://|file|cn_visio_professional_2013_with_sp1_x64_3910821.exe|566078120|238DBAB9F597E05EB93C06229AF3A57B|/</code></pre></li></ol><ol start="3"><li><p>MathType</p><p><a href="https://download.ismdeep.com/MathType6.9a-ismdeep.zip" target="_blank" rel="noopener">https://download.ismdeep.com/MathType6.9a-ismdeep.zip</a></p></li><li><p>VirtualDriveMaster（虚拟光驱软件）</p><p><a href="https://download.ismdeep.com/virtualdrivemaster.exe" target="_blank" rel="noopener">https://download.ismdeep.com/virtualdrivemaster.exe</a></p></li><li><p>文献管理软件 <a href="https://www.mendeley.com/download-desktop-new/" target="_blank" rel="noopener">Mendeley</a></p><p><a href="https://www.mendeley.com/" target="_blank" rel="noopener">https://www.mendeley.com/</a></p></li><li><p>Tex Live 2020</p><p><a href="https://mirrors.aliyun.com/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">https://mirrors.aliyun.com/CTAN/systems/texlive/Images/</a></p><p>地址来源： <a href="https://www.latexstudio.net/" target="_blank" rel="noopener">https://www.latexstudio.net/</a></p><p>macOS 上的 LaTeX 工具（MacTeX）也可以在这里找到。因为地址变化可能随时间而不同，所以就不贴下载地址了。</p></li><li><p>Texpad</p><p>macOS 下优秀的 LaTeX 编辑器。</p></li><li><p>CONNECTED PAPERS</p><p><a href="https://www.connectedpapers.com/" target="_blank" rel="noopener">https://www.connectedpapers.com/</a></p></li><li><p>SCI-HUB</p><p><a href="https://sci-hub.st/" target="_blank" rel="noopener">https://sci-hub.st/</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要列出了一些笔者常用的写论文软件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Office 2013&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;ed2k://|file|SW_DVD5_Office_Professional_Plus_2013_64Bit_Chn
      
    
    </summary>
    
    
      <category term="Windows" scheme="https://ismdeep.com/tags/Windows/"/>
    
      <category term="Study" scheme="https://ismdeep.com/tags/Study/"/>
    
  </entry>
  
</feed>
